Overview The processor on which this course is based is the Motorola MC68HC11 micro-controller, however, earlier Motorola microprocessors and peripherals may be used to illustrate some concepts. A micro-controller, such as the MC68HC11, is programmed using a dedicated set of instructions. These instructions specify the operation to be performed and the addressing mode to utilise when performing the operation. Stored program design (concept map) Objectives At the completion of this module you will be able to: describe the MC68HC11 Instruction Set and the interpretation of its major operations through considerations of several typical examples identify the essential components of problem solving techniques and demonstrate their use in assembly and machine program development. 11.1 The MC68HC11 Instruction Set The following tables list the MC68HC11 instruction set. These tables may appear complex, but once you become familiar with their contents they are fairly straightforward. You are not expected to remember every detail of each instruction, but you must be able to read and understand the tables in order to extract the required information. Table  11 . 1 :  Accumulator and memory instructions (Source: Motorola 1993,  M68HC11 E Series, Programming reference guide , pp. 19 – 35.) Table  11 . 2 :  Index registers and stack manipulation instructions Table  11 . 3 :  Jump and branch instructions (Source: Motorola 1993,  M68HC11 E Series, Programming reference guide , pp. 19 – 35.) Special operations Special operations, cont. (Source: Motorola 1993,  M68HC11 E Series, Programming reference guide , pp. 36 – 7.) Table  11 . 4 :  Condition code register manipulation instructions (Source: Motorola 1993,  M68HC11 E Series, Programming reference guide , pp. 19 – 35.) General points to note are that within each table the instructions are listed alphabetically and that each table covers a specific area. Table 11.1 gives a list of instructions that: include all instructions which involve either Accumulators A, B or D in their execution. e.g.  ‘ ADDA ’   –  add the operand addressed by the instruction into Accumulator A includes all instructions which operate directly on the contents of a memory location. e.g. CLR  ‘ M ’   –  clear the memory location with address  ‘ M ’ . Table 11.2 includes all instruction that operates on the contents of either the  ‘ index registers ’  or the  ‘ stack pointer ’ . Table 11.3 includes the complete list of  ‘ Branch ’  and  ‘ Jump ’  instructions. Table 11.4 includes the instructions that can be used to manipulate the contents of the condition code register. To appreciate the full details provided for each instruction consider the first few instructions from table 11.1 and the legend of symbols used. Table  11 . 5 :  Portion of the accumulator and memory instruction Starting from the left most column of table 11.5 we have the following: Mnemonic  –   The mnemonics used for the Add instruction for the 68HC11 are ADDA  –  for addition into accumulator A ADDB  –  for addition into accumulator B Operation   –  A brief explanation of the instruction. Boolean expression   –  For all tables, this column provides a quick reference as to the operation performed by the instruction. Addressing mode for operand   –  There are 6 addressing modes possible. i.e. Inherent (INH), Immediate (IMM), Direct (DIR), Extended (EXT), Indexed (IND,X or IND,Y), and Relative (REL). Consider the instruction, written in assembly code ADDA # $45 We understand this to mean  ‘ add the hexadecimal number 45 into Accumulator A ’ (i.e. immediate addressing). N.B.  ‘ $ ’  indicates  ‘ hexadecimal ’ ,  ‘ # ’  indicates immediate addressing. or (Acc A) + 45 16   →  Acc A From our discussions to date this would be stored in memory as Byte 1 (Opcode) Opcode (ADD) Register field (A) Addressing mode # (Immediate) Byte 2 (ii) 8 bit Operand (45 16 ) In fact the instruction is stored as two 8-bit bytes. The information contained in the  ‘ Machine Coding Column (Opcode) ’  allows us to select the appropriate binary code for the first byte. The information supplied under  ‘ Opcode ’  is the Operation Code or machine code, specified as a hexadecimal number i.e. OPCODE = 8B 16 . The actual binary digits stored for this instruction are: Byte 1 8B 16 1 0 0 0   1 0 1 1 Byte 2 45 16 0 1 0 0   0 1 0 1 Note  The hexadecimal number given in the  ‘ Opcode column ’  is the machine code that goes in the first byte of the instruction. Additional information given about  ‘ ADDA using immediate addressing ’  appears as follows: In the  ‘ Cycles column ’  there is the entry  ‘ 2 ’ . A check against the legend indicates this is the  ‘ number of MPU cycles ’  it takes to fetch and execute this instruction. This information is provided so that at the end of a program the programmer can calculate how long the program will take to execute. This may be important because: the program may be controlling some external process and strict time limits may have to be met for safety reasons. To ensure that the program can be executed within the limits the time for execution must be calculated. the programmer may have to program a  ‘ delay ’  e.g. between successive outputs to a terminal. This can be done by writing a program to count down an accumulator to zero. The time taken gives the delay and is determined by the execution times of the instructions involved. In the  ‘ Bytes column ’  there is an entry 2. Consulting the legend this column indicates the number of program bytes required to store this instruction in memory. i.e.  ‘ ADDA #$45 ’  is a 2 byte instruction. Byte 1 8B 16 1 0 0 0   1 0 1 1 Byte 2 45 16 0 1 0 0   0 1 0 1 A similar analysis also applies for the other addressing modes. Example 1 What is the machine code for the ADDB $45, X and ADDB $45, Y instructions. Solution The entries for the  ‘ ADDB ’  row of table 11.1 are: From our studies of indexed addressing we know the instruction requires at least two bytes and this is confirmed by the entry in the  ‘ Bytes  column ’  for addressing modes  ‘ IND,X  and  IND,Y ’ . For IND,X the two bytes will contain the following: Byte 1 (EB 16 ) Opcode (ADD) Register field (B) Addressing mode (Indexed) Byte 2 (ff) A positive 8 bit offset (45 16 ) For IND,Y the three bytes will contain the following: Byte 1 (18 16 ) Pre-byte Byte 2 (EB 16 ) Opcode (ADD) Register field (B) Addressing mode (Indexed) Byte 3 (ff) A positive 8 bit offset (45 16 ) The machine code for these instruction is therefore: ADDB $45, X Byte 2 EB 16 1 1 1 0   1 0 1 1 Byte 3 45 16 0 1 0 0   0 1 0 1 ADDB $45, Y Byte 1 18 16 0 0 0 1   1 0 0 0 Byte 2 EB 16 1 1 1 0   1 0 1 1 Byte 3 45 16 0 1 0 0   0 1 0 1 The offset of 45 16  is the value specified by the programmer in the instruction. Example 2 What is the machine code for the instruction? ADDA VALUE where  ‘ VALUE ’  is the name given to a memory location (00B6 16 ) that contains the number to be added to the accumulator. Solution This instruction may be written in an alternative form as: ADDA $00B6 The concept of using a  ‘ name ’  for a memory location rather than specifying the  ‘ actual address ’  is one that you are encouraged to adopt. This method is used extensively when writing assembly language programs because it makes the program easier to follow and debug, particularly if someone else has written it. When using  ‘ names for locations ’  it is essential you adopt the procedure used for writing assembly language programs, where at the beginning of each program all names are declared. These  ‘ names for locations ’  are referred to as  labels. e.g.   VALUE    EQU    $00B6 The  ‘ EQU ’  directive is a signal to the assembler that wherever  ‘ VALUE ’  appears in the program the address  ‘ 00B6 16 ’  is intended.  ‘ VALUE ’  is a label. The solution to this problem then is to find the machine code for ADDA $00B6 As there is no  ‘ addressing symbol ’  used (such as  ‘ # ’  or  ‘ , X ’ ) and the instruction is not a  ‘ branch instruction ’  then the addressing mode intended is either ‘ direct addressing ’  or  ‘ extended addressing ’ Because the address of the memory location is 00B6 16 direct addressing  can be used since the  ‘ high-byte ’  of the address is  ‘ 00 ’ . The instruction is then ADDA $B6 Previous work shows the information supplied in this 2-byte instruction is: Byte 1 (9B 16 ) Opcode (ADD) Register field (A) Addressing mode (Direct) Byte 2 (dd) Low byte of the operand address (B6 16 ) The execution of this instruction will result in the contents of memory location 00B6 16  being added to Accumulator A. Consulting the  ‘ Machine Coding ’  column of table 11.1 gives the actual machine code as: Byte 1 9B 16 1 0 0 1   1 0 1 1 Byte 2 B6 16 1 0 1 1   0 1 1 0 Checking the  ‘ Bytes ’  column confirms it is a 2 byte instruction and the  ‘ Cycles ’  column indicates that it takes 3 machine cycles to execute. This same instruction could be coded into machine code using  ‘ Extended addressing ’  in which case ADDA $00B6 would be coded as a 3 byte instruction as follows: Byte 1 BB 16 1 0 1 1   1 0 1 1 Byte 2 00 16 0 0 0 0   0 0 0 0 Byte 3 B6 16 1 0 1 1   0 1 1 0 Note the execution time is now 4 machine cycles since an extra byte has to be fetched from memory. Although the program would still run and would provide the correct operation it would use an additional memory location and would take longer to execute, i.e. it is less efficient. Example 3 Why is there no INH (inherent) entry in the  ‘ Addressing mode ’  column for the  ‘ ADDA ’  and  ‘ ADDB ’  instructions? Solution Inherent addressing covers both  ‘ implied addressing ’  and  ‘ accumulator addressing ’ . In each case the  ‘ addressing mode ’  is inherent in the OPCODE. e.g.   CLRA  –  clear Accumulator A (accumulator addressing) INX  –  increment the index register (implied addressing) In each case no operand need be specified as the operation involves only the  ‘ Accumulator A ’  in  ‘ CLRA ’  and the  ‘ index register ’  in  ‘ INX ’ . For the  ‘ ADDA ’  and  ‘ ADDB ’  instructions obviously some  ‘ operand ’  has to be specified, i.e. some memory contents or data have to be specified to be added to the appropriate accumulator. Therefore  ‘ implied addressing ’  and  ‘ accumulator addressing ’  have no significance for these instructions. Example 4 It has been stated several times throughout this section, that the hexadecimal digits provided in the  ‘ Machine Code ’  column of the instruction set, is the machine code for the  ‘ first byte ’  of the instruction and represents Opcode Register field Addressing mode By comparing these  ‘ Machine Code ’  column values for all the  ‘ ADDA ’  and  ‘ ADDB ’  addressing options, determine which bits of the machine code represents the information in the  ‘ first byte ’ . Solution By comparing the machine code bits for ADDA and ADDB with the same addressing mode it can be seen that they differ in the  ‘ Bit 6 ’  position. The  ‘ register field bit ’  is bit 6 of the machine code. For Accumulator A, Bit 6 is [0]. For Accumulator B, Bit 6 is [1]. By comparing the machine code bits for the ADDA instructions with the different addressing modes it can be seen that Bits 4 and 5 indicate the addressing mode. i.e. Bit 5 Bit 4 Address mode 0 0 1 1 0 1 0 1 Immediate Direct Indexed Extended The remaining bits specify the OPCODE. Boolean/arithmetic operation.  For all tables, this column provides a quick reference as to the operation performed by the instruction. Most of the symbols used are specified in the legend given in table 11.1. Those omitted are as follows: A – Contents of Accumulator A B – Contents OF Accumulator B M – Contents of the memory location (or data for immediate addressing) as addressed by the instruction C – Carry bit X – Contents of index register X Y – Contents of index register Y XH – Contents of the high byte of the index register XL – Contents of the low byte of the index register SP – Contents of the Stack Pointer Note  The symbol  ‘ + ’  is intended as the  ‘ arithmetic plus ’  for all instructions except the INCLUSIVE-OR and the  branch instructions  where it represents  logical   ‘ OR ’ . Boolean expression in table 11.3.  This column indicates  exactly  the conditions under which the conditional branch will occur. All expressions are logical or Boolean expressions. e.g. The entry for  ‘ BMI ’  instruction ’ . Note that it can be used with  ‘ relative addressing only ’ , the machine code is 2B 16 , it takes 3 machine cycles to execute, it is a 2 byte instruction and the condition that must exist for the branch to occur is the  ‘ negative bit ’ , N, must equal 1. Some of the branch tests are quite complicated and these will be discussed later. Warning: Ensure you check and understand the  ‘ branch test ’  when selecting the appropriate branch instruction. e.g. BMI (Branch if minus) and BLT (Branch if less than zero) may appear to be the same. BMI will cause a branch if N = 1 i.e. if the MSB of the result of the last operation is [1]. BLT will cause a branch if N = 1 providing the  overflow is not set  i.e. (N  ⊕  V) = 1, it will also branch if N = 0 providing the overflow is set. Boolean operation in Table 11.4.  This indicates a quick reference to the instructions that can be performed on the condition code register. CCR  –  Condition code register Condition code register . This section of all the tables is split into 8 columns, one for each condition code bit, and indicates the affect the instruction execution has on each bit in the condition code register. The possible conditions that can apply for the setting of the condition code bits are indicated for each. The symbols used are briefly explained in the  ‘ Legend ’  below table 11.1 and are as follows: This symbol against an instruction indicates that the value of the condition code bit is unaffected, i.e. if set, it remains set, if reset it remains reset. Note that none of the branch instructions affects the condition code bits. e.g. if the result of the operation is zero then the  ‘ Z-bit ’  will be [1]. Obviously if the  ‘ Z-bit ’  is [1] then the result is not negative and hence the  ‘ N-bit ’  will be zero. Details for setting the condition code bits in the status register have been outlined in previous modules. 1 This symbol indicates that it is  ‘ set ’  as a result of the instruction without any test conditions applying. 0 This symbol indicates it is  ‘ Reset ’  without any test conditions applying. ↓ This symbol indicates that it may be reset, but not set. Points to note The M68HC11 can perform certain operations directly on the contents of a memory location without first bringing them into an accumulator. e.g. ‘ CLR ’   instruction ‘ DEC ’ ” ‘ COM ’ ” ‘ INC ‘ ”  etc. These instructions may be identified by the entries in the  Boolean expression  column. If an accumulator is used then  ‘ A ’  or  ‘ B ’  will appear. If the instruction applies directly to memory contents then  ‘ M ’  appears by itself. i.e. For  ‘ DEC ’  the entry is  ‘ M  –  1  →  M ’ Certain instructions have restricted  ‘ addressing modes ’ . e.g.The COM, NEG, DEC, ROL, ROR, ASL, ASR, etc. instructions only allow  ‘ Indexed and Extended Addressing ’  when referencing a location in memory. All  ‘ compare ’  and  ‘ test ’  instructions merely set the flags according to the result obtained from the operation performed, but do not store the result. e.g. CMPA $1F3B This instruction subtracts the contents of location 1F3B 16  from the accumulator and sets all the condition codes according to the result. The actual contents of the accumulator remain unchanged. A  ‘ compare ’  or  ‘ test ’  instruction is always followed by a conditional branch i.e. Or   BEQ  –  Branch if equal to zero BNE  –  Branch if not equal to zero etc. Conditional Branch Instructions Refer to table 11.3 To give an indication of the significance of the branch conditions, it is best to consider them in pairs. BCC/BCS instructions  –  These allow the program to test the status of the  ‘ carry bit ’ . The  ‘ carry bit ’  may have been set as a result of an arithmetic operation or as a result of one of the Shift/Rotate instructions.  BEQ/BNE instructions  –  The condition for branching is based exclusively on the  ‘ Z-bit ’  and tests for the  ‘ Result = 0 ’ . BVS/BVC instructions  –  These test the  overflow bit  and provide a means of ensuring that the binary data does not exceed the limits of 8-bit 2 ’ s complement arithmetic. BPL/BMI instructions  –  These test the MSB of the result, i.e. the  ‘ sign bit ’ , and should be used only with  ‘ signed numbers ’ , i.e. 2 ’ s complement numbers. Note that they do not test for the possibility of an  overflow . BLT/BGE instructions  –  These are very similar to the BPL/BMI instructions but in addition to checking the  ‘ sign-bit ’  they also check for a 2 ’ s complement overflow. BGT/BLE instructions  –  These are very similar in test to the BLT/BGE instructions but with the added test to put the decision point above the zero value instead of below it. BHI/BLS instructions  –  These are special instructions in that they apply for  ‘ unsigned numbers ’ , i.e. the MSB does not indicate the  ‘ sign ’  and 2 ’ s complement numbers are not being used. Example 5 Let Accumulator A contain E7 16  and memory location 0001 16  contains 7E 16 . What instructions would be used to cause a program to  branch  if the contents of the accumulator are less than the contents of the memory location. Assume a  ‘ signed number ’  system, i.e. the numbers are 2 ’ s complement values. Repeat a. for an  ‘ unsigned ’  number system. Solution To determine if the number in Accumulator A is less than that in memory location 0001 16  then first a  ‘ compare ’  instruction is required. i.e. CMPA $ 01 (direct addressing) This operation results in the condition codes being set according to the following calculation: i.e. (ACCA)  –  (location 0001 16 ) or (E7  –  7E) which is equivalent to ( – 25 10   – 126 10 ) for a  ‘ signed 2 ’ s complement system ’ . A close examination of table 11.3 indicates possible suitable branch instructions are: BMI  –  Branch if minus (tests for N = 1) BLT  –  Branch if less than zero (test is N  ⊕  V = 1) as it is  ‘ signed numbers ’  we are considering, these are the only appropriate choices. To select the appropriate instruction consider the actual operation performed by the ALU. E7 16  is 1 1 1 0 0 1 1 1 7E 16  is 0 1 1 1 1 1 1 0 2 ’ s complement of 7E 16  is 1 0 0 0 0 0 1 0 E7 16   –  7E 16  results in From this result the condition code values would be as follows: N = 0 – MSB = 0 Z = 0 – result is not zero V = 1 – overflow has occurred – i.e. the 2 numbers added are both negative but the result is positive. C = 0 – Since the CPU subtracts using the 2 ’ s complement method, we need to invert the carry result to get the correct status. Note  In this example the carry generated by performing the subtraction using 2 ’ s complement arithmetic is discarded and is  not the borrow  resulting from the subtraction. This can be identified by performing normal subtraction as follows: E7 16   –  7E 16  is i.e. there is  no borrow  therefore the  ‘ C-bit ’  of the condition code register is [0]. The result of a branch should indicate the E7 16  ( – 25 10 ) is less than 7E 16  (+126 10 ). The  ‘ BMI instruction checks for N = 1. But N = 0 therefore this instruction would not branch and would give the incorrect result. The BLT instruction performs the test (N  ⊕  V) which is [1] and would cause the correct branching operation. The appropriate instructions are then CMPA $ 01 BLT (offset distance) For an unsigned number system E7 16  is 231 10  and 7E 16  is 126 10  and as such no branch should occur. The  ‘ compare instruction ’  is still required and the condition code bits will be set identical to that in (a). From the summary given in Conditional Branch Instructions above the only instructions that can be used for unsigned numbers are BLS or BHI BLS results in a branch if the contents of 0001 16  are  ‘ same or less than ’  the contents of Accumulator A. This example requires that  ‘ it be less than ’  that of Accumulator A. This can be provided as follows: CMPA $ 01 BEQ 02 BLS ( offset ) If the numbers are the same then the  ‘ BEQ ’  instruction will jump forward over the BLS instruction. (N.B. Firstly branch instructions do not alter the condition codes and secondly, the branch  ‘ 02 ’  is required since the BLS instruction is 2 bytes long.) This ensures that the BLS instruction will only branch if the contents of 0001 16  are less than Accumulator A. Special instructions  in table 11.3, include instructions which do not fall under any general category. NOP or  ‘ No Operation ’  instruction. This is a single byte instruction which  ‘ does nothing ’  except increment the program counter to the next instruction. It is very useful since the inclusion of  ‘ NOP ’  instructions in a program allow extra instructions to be added without altering the locations of all the program. Similarly if an instruction is deleted during the  ‘ debugging phase ’  it can be replaced with  ‘ NOP ’ s ’ . WAI This instruction is used when the timing of an input/output is controlled by an external interrupt. Its use will be demonstrated in a later module. JSR Allows the program to  ‘ Jump to Subroutine ’  and note that  ‘ indexed ’  and  ‘ extended ’  addressing can be used to specify the start address of the sub routine. e.g. JSR $ 101F This will cause the program to jump to the subroutine whose first instruction is located at memory location 101F 16 . (See the illustration following table 11.3.) On a  ‘ JSR ’  the value on the  ‘ program counter ’  (which points to the next instruction address in the main program) is pushed on the stack and the address specified by the JSR instruction (e.g. 101F 16 ) is put in the PC. RTS The end of the subroutine is indicated by an RTS instruction and causes the original value of the PC to be returned from the  stack . (See the illustration following table 11.3.) BSR A branch to subroutine uses relative addressing to specify the subroutine address. This allows the subroutine to start at a location which must be within the range +127 to  –  128 locations of the current value of the PC. SWI In summary, When the SWI is executed the PC, XREG, Acc A, Acc B and Condition Code register contents are saved on the  stack . (N.B. The PC contains the address of the instruction following the SWI.) The new PC value is taken from memory locations FFFA 16  and FFFB 16 . i.e. These supply the address of the  ‘ service routine for the Software Interrupt ’ . The Service Routine is then run. The effect of the SWI is identical to an  ‘ external hardware interrupt ’  which alerts the processor by activating an  ‘ Interrupt Request ’  line. RTI The final instruction of an Interrupt Service Routine must be this instruction. When executed it causes all the register contents to be returned from the  stack . This returns the original value of the PC which is the address of the next instruction and allows the main program to continue. (See the illustration following table 11.3.) Activity  11 . 1 All questions refer to the MC68HC11 series microprocessors. What is meant by the shorthand notation: A + B > A? How is the C flag affected by the  ‘ add ’  and  ‘ add with carry ’  instructions? Is the C flag changed when the AND instruction is executed? Explain the difference between the NEG instruction and the COM instruction. Explain the difference between the ANDA instruction and the BITA instruction. The decimal adjust instruction is associated with which accumulator? When the RORA instruction is executed the LSB of Accumulator A is shifted into the __________    register. List eleven operations that can be performed directly on an operand in memory without first loading it into one of the MPU registers. Explain the difference between the SUBB instruction and the CMPB instruction. List the four types of logic operations that the  ‘ 68HC11 MPU can perform. When the LDX instruction is executed, from where is the index register loaded? List four conditional branch instructions that are commonly used after a compare or subtract instruction to compare two ’ s complement numbers. Explain the difference between the BGT and BHI instructions. Which instruction is often used to fill in a hole left in a program after an unwanted byte is removed? Which of the condition codes can be individually set or cleared? What is the difference between an unconditional branch instruction and a conditional branch instruction? What condition is tested by the branch if minus (BMI) instruction? When is the N flag set? When is the Z flag set? During an add operation, the C flag is set. What does this represent? During a subtract operation, the C flag is set. What does this indicate? Often, when two positive 2 ’ s complement numbers are added, the sign bit of the answer will indicate a negative sum. This  ‘ error ’  can be spotted by checking which flag? Under, what condition will the BEQ instruction cause a branch to occur? Under what condition will the BPL instruction cause a branch to occur? When subtracting unsigned binary numbers, which flag indicates that the difference is a negative number? 26. How is the ADC instruction different from the ADD instruction? 27. How is the SBC instruction different from the SUB instruction? 28. A primary use of the ADC and SBC instructions is in ____________ arithmetic. 29. The accumulator contains the number 7 10 . If two ASLA instructions are executed, what number will be in the accumulator? 30. The BRA instruction will cause a branch to occur: Anytime that it is executed. Only if the Z flag is set. Only if the N flag is set. Only if the C flag is set. 31. The  ‘ operand address field ’  that follows the opcode of an unconditional branch instruction is: The address of the operand. The address of the next opcode to be executed. Added to the program count to form the address of the next opcode to be executed. Added to the program count to form the address of the operand that is to be tested to see if a branch operation is required. 32. The opcode for an unconditional branch instruction is at address AF 16 . The relative address is 0F 16 . From what address will the next opcode be fetched? A0 16 C0 16 BE 16 B1 16 33. The opcode for an unconditional branch instruction is at address 30 16 . The relative address is EF 16 . From what address will the next opcode be fetched? 21 16 EF 16 32 16 19 16 34. The carry register: Acts like the ninth bit of the accumulator. Is set when a  ‘ borrow ’  for bit 7 of the accumulator occurs. Is set when a carry from bit 7 occurs. All the above. 35 The numbers 0101 10002, and 0110 00112, are added using the ADD instruction. Immediately after the ADD instruction is executed, the condition code registers will indicate the following: C = 1, N = 1, V = 1, Z = 0 C = 0, N = 1, V = 1, Z = 0 C = 0, N = 1, V = 0, Z = 0 C = 0, N = 0, V = 1, Z = 1 36. When you are adding multiple-precision binary numbers, all bytes except the least significant ones must be: Added using the ADD instruction. Added using the DAA instruction. Added using the ADC instruction. Decimal adjusted before addition takes place. Solutions are provided at the end of the module. 11.2 Program formatting We now have all the information necessary to write programs in machine language to solve any problem. It should be noted, however, that all programs must be written in a strict format, which all other programmers can understand. Even a program written by you a week ago would now be difficult to recall if you don ’ t document it in a standard format. This fact cannot be emphasised enough and be warned  –   ‘ programs submitted in some other format will not be accepted as assignments in this course. ’ The format is simple and logical and it uses a fixed set of columns known as  ‘ fields ’ . The technique used to solve problems often differs from programmer to programmer however in this course we will again follow a  ‘ standard technique ’ , which will at least guarantee you success in solving problems. 11.2.1 Problem solving techniques There are 4 basic steps in solving a problem. These are: Step 1  –  a flowchart The flowchart is a block diagram used to graphically illustrate the technique used by the programmer to solve the problem. The words used in each block (or box) are standard English language and are  never  abbreviated computer jargon for a particular computer. The flowchart should be an explanation only of how the problem can be solved on any computer. Flowchart symbols: There are five basic symbols used to draw flowcharts. Each corresponds to one of the five basic functions of a computer, as follows: A subroutine can be considered as a separate predefined process. When the program reaches this block, the main program is halted and flow passes to the subroutine. At the end of the subroutine flow returns to this block and the main program continues. Subroutines must be shown as a separate flowchart with a Start block at the beginning and a Return block at the end. Step 2  –  a memory map The memory map is a diagram showing the memory addresses used for data, I/O devices, the program itself and any unused memory. It will vary from processor to processor according to the available memory addresses. The next two steps describe the program itself, which is written in two sections as shown. Step 3  –  the assembly language section This section contains everything (labels, mnemonics, operands and comments) except the actual codes used by the processor. We will see later that by describing this section to an  ‘ assembler program ’  on another computer we can automatically generate machine codes and so avoid the process described in Step 4. Step 4  –  the machine coded section This section of the program lists the actual addresses used by a particular processor together with the machine codes relevant for that processor. It is the only part of the whole programming process, which the computer itself understands. As mentioned previously when writing and coding programs it is essential to present them in a format, which is consistent with that given by most assemblers. All programs you write should follow this format: Label field   –  It is convenient to give labels to certain instructions in the program. This makes it easy to follow. e.g. START and END (or STOP) Its major use however is to indicate  branch destinations . e.g. BPL LOOP indicates the branch destination, i.e. the instruction to be executed immediately after a  ‘ branch ’ ,  is that against the label LOOP, i.e. ADDA instruction. Mnemonics field   –  Contains the mnemonic of the instructions only. Operand   field   –  Contain the  ‘ address mode symbol ’  and the  ‘ operand ’ . Note: Use labels and names for operands rather than hexadecimal address. Comment   field   –  A brief comment on the function of the instruction. Programming example 1 The foregoing process is best illustrated by an example. We will reprogram the previous example given in section 8.5. Write a complete program using the stored program concept to perform the following numerical exercise: 9  –  5 + 2 on a Motorola  ‘ 68HC11 series processor. The result is to be stored in a memory location labelled ANS. Step 1:  Flowchart Step 2:  Memory map Step 3:  Assembly language program Step 4:  Machine code program Notes:   This program must be designed to operate on the M68HC11 series processor. Its memory space (allocated by the manufacturer) available to the programmer is 1100 to B600. We will also illustrate the use of  labels , which were mentioned in section 11.1.2. In this problem we will allocate labels to the data in this problem. For instance: Data Label 9 5 2 Result NUM1 NUM2 NUM3 ANS Remember labels are not recognized by the computer, however, they are used extensively in designing programs as they assist in layout and understanding of the programming techniques used. Step 1  –  Flowchart Step 2  –  Memory map Steps 3 and 4  –  Program sections Note the use of extended addressing modes because the memory address locations are 16 bits in length. Machine Code Section (Step 4) Assembly Language Section  (Step 3) Address Operation code Label field Mnemonics field Operand field Comments field 1100 1101 1102 1103 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 111A 111B 111C 111D 111E B6 11 00 B0 11 01 BB 11 02 B7 11 03 7E 11 1C NUMl NUM2 NUM3 ANS START HALT LDAA SUBA ADDA STAA JMP 9 5 2 NUMI NUM2 NUM3 ANS HALT Number 1 =9 Number 2 = 5 Number 3 = 2 Location reserved for answer Loads Accumulator A with Number 1 from location 1100 Subtracts Number 2 from the Accumulator Adds Number 3 to the  Accumulator Stores the result in Accumulator A into location 1103. Halts the process at this point Not an ideal way to end a program, but acceptable in this course. Note:     This program is not designed to run on the 68HC11 microcontroller. This program would be started at location $1110 after it has been typed into the CPU RAM. Let us now consider another example where the assembly language program has been developed by someone else and we are to describe its operation and code it for a  ‘ 68HC11 series processor with memory addresses as given. Programming example 2 Consider the following Assembly Language Program: Label field Mnemonic field Operand field Comment field START LOOP END LDX CLRA ADDA DEX BPL JMP #$0004 $00,X LOOP END Set the XREG = 4 Clear Accumulator A Add (M) into Accumulator A Where M = (XREG) + 00 Decrement XREG for next value For M > 0000 go back to loop Stop the program Describe the function of the program and code it into machine code with the program starting at location 0010 16. Solution Before solving the problem note the function of each of the columns. The function of this program is to sum the contents of the memory locations 0000 16  to 0004 16 , i.e. a table, leaving the answer in the accumulator. Note how indexed addressing is used to point to the next entry in the table each  ‘ pass through the loop ’ . Let the contents of 0000 16  to 0004 16  be as follows: Location Contents 0000 01 0001 02 0002 03 0003 04 0004 05 The register contents as the program is run would then be as follows: After the program has just executed the CLRA instruction Acc A = 0 XREG = 0004 When the program is about to execute BPL LOOP for the first time Acc A = 05 16  (i.e. contents of 0004 16  have been added to it) XREG = 0003 16 As the  ‘ DEX ’  instruction set the  ‘ condition codes ’  and the result is 0003 16  then the BPL instruction will cause the program to branch back to LOOP and repeat at the  ‘ ADDA ’  instruction. When the program is about to execute BPL LOOP for the second time Acc A = 09 16 XREG = 0002 16 When program is about to execute BPL LOOP for the third time Acc A = 0C 16  (i.e. 5 10  + 4 10  + 3 10  = 12 10  = C 16 ) XREG = 0001 16 After the fourth time Acc A = 0E 16 XREG = 0000 16 Note this is still positive (i.e. N bit = 0) so it will branch one more time. After the fifth time Acc A = 0F 16  (i.e. 15 10 ) XREG = FFFF 16  (i.e. 0000 16 – 1) which means the N bit = 1 and the  branch  will not occur therefore the next instruction will be the JMP END instruction which is an endless loop that effectively stops the program. Resetting the processor with terminate the program properly. The fully coded program is as follows: Address Operation code Label field Mnemonic field Operand field Comment field 0010 0011 0012 0013 0014   CE 00 04 4F AB   START       LOOP   LDX     CLRA ADDA   #$0004       $00,X   Set the XREG = 4     Clear Acc A Add (M) into Acc A Where M = (XREG) + 00 0015 0016 0017 0018 00 09 2A FB           DEX BPL       LOOP   Decrement XREG for next M For M > 0000 go back to loop   0019 001A 001B 7E 00 19 END     JMP     END     STOP     The machine language program is written by selecting the appropriate machine code from the instruction set. e.g. LDX  #$0004 is coded into three bytes as follows: N.B. In some references the assembly code for this instruction is written as LDX #$04 This is valid, however, care should be exercised to check that it is in fact a 3-byte instruction. This can be found in the  ‘ bytes column ’  of the instruction details. Coding for the remainder of the instructions should be straight forward except possibly the  ‘ BPL LOOP ’  instruction. The machine code for  ‘ BPL LOOP ’  is Byte 1 2A Byte 2 OFFSET The value of the OFFSET is that value which when added to the current value of the PC will cause the next instruction to be fetched from location 0014 16  (i.e. the  ‘ ADDA ’  instruction). This is  relative addressing . When the  ‘ BPL LOOP ’  instruction is executed the PC will already have been incremented to point at the next instruction. i.e. PC = 0019 16 Therefore, the address calculation will be as follows: 0019 16  + OFFSET = 0014 16 or  OFFSET =  – 5 This OFFSET is held as a 2 ’ s complement value, which for  – 05 16  is FB 16 . Activity  11 . 2 Label field Mnemonic field Operand field Comment field START LOOP STOP CLRA TST BEQ DEC ADDA BRA JMP $0020 STOP $0020 $21 LOOP STOP Clear Accumulator A Test the Multiplier If it is zero STOP Otherwise decrement the multiplier Add Multiplicand to the Product Repeat the loop Figure  11 . 1 :   This program performs a multiplication by repeated addition. The memory locations reserved for variables are as follows: Multiplier  = Address 0020 16 Multiplicand  = Address 0021 16 Let the Multiplier = 05 16 , the Multiplicand = 04 16  and the program when coded into machine code is to start at Address 0010 16 . In relation to the program in figure 11.1 answer the following questions. Code the program into machine code with starting address 0010 16 . What addressing mode does the TST instruction use? Immediate Direct Extended Indexed The BEQ instruction checks to see if the TST instruction set the: Z flag C flag H flag V flag The DEC instruction decrements the number in: Accumulator A Memory location $0020 Accumulator B The index register 5. Which instruction is executed immediately after the BRA instruction? WAI BEQ CLRA TST 6. With the values given for the multiplier and multiplicand, how many times will the main program loop be repeated? Four times Five times Twenty times Twice 7. After the program has been executed, memory location $0020 will contain: 05 16 04 16 20 16 00 16 8. After the program has been executed, the product will appear in: Memory location $0020 Memory location $0021 Accumulator A Accumulator B Label field Mnemonic field Operand field Comment START LOOP STOP LDX LDAA ADDA STAA INX CPX BNE JMP #$0005 $20,X $30,X $40,X #$0015 LOOP STOP Figure  11 . 2 :   For questions 9 – 14 refer to the program in figure 11.2. 9. Analyse the program and determine what it does. 10. Code the program into machine code with starting address 0010 16  and fill in the appropriate comments in the  ‘ comment field ’ . 11. On the first pass through the main program loop, the  ‘ LDAA $20,X ’  instruction takes into operand from memory $0005 $0020 $0025 $0014 12. On the first pass, the  ‘ ADDA $30,X ’  adds the contents of what memory location to Accumulator A? $0005 $0030 $0035 $0016 13. On the second pass through the program loop, the contents of memory location: $0021 are added to the contents of $0031 and the result is stored in $0041. $0026 are added to the contents of $0036 and the result is stored in $0046. $0025 are added to the contents of $0035 and the result is stored in $0045. $0020 are added to the contents of $0030 and the result is stored in $0040. 14. How many times is the main program loop repeated? 10 16  times 05 16  times 30 16  times 15 16  times Activity 11.1 solutions  Add the contents of Accumulator A to the contents of Accumulator B; transfer the result to Accumulator A. The C flag is set if a carry occurs; it is cleared otherwise. No, the C flag is unaffected by the AND instruction. The COM instruction replaces the operand with its 1 ’ s complement. The NEG instruction replaces the operand with its 2 ’ s complement. With the ANDA instruction, the result of the AND operation is placed in Accumulator A. With the BITA instruction, the condition code registers are set according to the result but the result is not retained. The decimal adjust instruction works only with the Accumulator A. Carry (C). A byte in memory can be: cleared, incremented, decremented, complemented, negated, rotated left, rotated right, shifted left arithmetically, shifted right arithmetically, shifted right logically, and tested. With the SUBB instruction, a difference is produced and placed in Accumulator B. With CMPB, the flags are set as if a difference were produced, but the difference is not retained. Complement, AND, inclusive OR, and exclusive OR. The upper half of the index register is loaded from the specified memory location; the lower half from the byte following the specified memory location. BGE, BGT, BLE, BLT. BGT is used to test the result of subtracting two ’ s complement numbers. BHI is used to test the result of subtracting unsigned numbers. NOP C, I and V An unconditional branch instruction always causes a branch operation to occur. On the other hand, the conditional branch instruction implements a branch operation only if some specified condition is met. The BMI instruction tests the Negative (N) bit of the Condition Code register to see if it is set. Generally speaking, the N flag is set if the previous instruction left a 1 in the MSB of the accumulator. Generally, the Z flag is set if the previous instruction left all zeros in the accumulator. During an add operation, the carry bit is set if there is a carry from bit 7 of the accumulator. During a subtract operation, the carry bit is set if bit 7 had to  ‘ borrow ’  a bit to complete the subtraction. This condition results from a two ’ s complement overflow. Thus, the V flag will be set if this condition occurs. 23. The BEQ instruction causes a branch to occur only if the Z bit is set. 24. The BPL instruction causes a branch to occur only if the N bit is clear. 25. The carry flag. 26. When the ADC instruction is executed, an additional 1 is added to the sum if the carry flag is set. 27. When the SBC instruction is executed, an additional 1 is subtracted from the difference if the carry flag is set. 28. Multiple-precision. 29. The first ASLA instruction multiplies the number by two, giving 14 10 . The second ASLA doubles this number, giving 28 10 . 30. a.  –   The BRA instruction causes a branch anytime that it is executed. 31. c.  –   The address that follows a branch opcode is added to the program count to form the address of the next opcode to be executed. 32. b.  –   During the execution of the branch instruction, the program counter is advanced twice to B1 16 . Thus, when the relative address ( 0F 16 ) is added, the new address becomes  C0 16 . 33. a.  –   The execution of the branch instruction increments the program counter to 32 16 . When the relative address (EF 16 ) is added, the new address becomes 0011 0010 2 32 16 1110 1111 2 EF 16 1 0010 0001 2 1 21 16 Ignore Carry ↑ Ignore Carry ↑ 34. d.  –   The carry register performs all the functions listed. 35. b.  –   The result of this addition is 0101 1000 2 0110 0011 2                                    1011 1011 2 The C flag is cleared to 0 because there was no carry from bit 7. The N flag is set to 1 because bit 7 is 1. The V flag is set to 1 because, if you consider the numbers to be signed binary, the addition of two positive numbers resulted in a negative answer. The Z flag is cleared to 0 because the result is not zero. 36. c.  –   The ADC instruction must be used when you are adding multiple-precision numbers. Activity 11.2 solutions  Address Operation code Label field Mnemonic field Operand field Comment field 0010 0011 0012 0013 0014 0015 0016 0017 0018 0019 001A 001B 001C 001D 001E 001E 4F 7D 00 20 27 07 7A 00 20 9B 21 20 F4 7E 00 1D START LOOP STOP CLRA TST BEQ DEC ADDA BRA JMP $0020 STOP $0020 $21 LOOP STOP Clear Accumulator A Test the Multiplier If it is zero STOP Otherwise decrement the multiplier Add the Multiplicand to the product Repeat the loop STOP 2. c.  –   Extended. 3. a.  –   The BEQ instruction tests the Z flag. 4. b.  –   The DEC instruction decrements the number in memory location $0020. 5. d.  –   The relative address (F4) directs the program back to the TST instruction. 6. b.  –   The multiplier (05) is decremented on each pass until it reaches 00. Thus, the loop will be repeated five times. 7. d.  –   The multiplier is reduced to 00 as the program is executed. 8. c.  –   The product appears in Accumulator A. 9. This program adds together the corresponding values of two equal sized tables and stores a result in a third table. The tables are stored as follows: Table 1 is in locations 0025 16  to 0034 16 Table 2 is in locations 0035 16  to 0044 16 Table 3 (answers) is in locations 0045 16   to 0054 16 LDAA $20,X takes a value from table 1 into ACCA ADDA $30,X adds the corresponding value from table 2 into Acc A STAA $40,X stores this value in table 3 This procedure is then repeated 16 10  or 10 16  times. 10. Address Operation code Label field Mnemonic field Operand field Comment field 0010 0011 0012 0013 0014 0015   0016 0017 0018 0019 00lA 001B 001C 001D 001E 001F 0020 0021 CE 00 05 A6 20 AB   30 A7 40 08 8C 00 15 26 F4 7E 00 1F START     LOOP                         END LDX     LDAA   ADDA     STAA   INX CPX     BNE   JMP #$0005     $20,X   $30,X     $40,X     #$0015     LOOP   END Set Index Register to $0005     Load ACCA from Address M where M = $20 + XREG Add the contents of location  ($30 + XREG) into Acc A   Store Acc A into the location ($40 + XREG) increment XREG for next value Compare the index register to $0015   If not equal to $0015. Go back to loop  Yes  –  STOP 11. c.  –   The Offset address ($20) is added to the number in the index register ($0005) to form an operand address of $0025. 12. c.  –   The contents of location $0035 are added to Accumulator A on the first pass through the loop. 13. b.  –   On the second pass, the contents of location $0026 are added to the contents of location $0036. The result is stored at $0046. 14. a.  –   The index register starts at $0005 and is incremented to $0015. Therefore, the loop is repeated 10 16  times.