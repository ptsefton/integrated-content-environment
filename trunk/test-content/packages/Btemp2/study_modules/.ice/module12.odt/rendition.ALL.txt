<?xml version="1.0"?>
<html><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>Software assemblers, editors and simulators</title><style type="text/css">table {border-spacing: 0;empty-cells: show; }
.body .indent {margin-left: 25px;}
.body .hint {font-size: 1.4em; font-style: normal;font-weight:bolder;color: #00000;}
.spCh {font-family: 'Lucida Grande','Arial Unicode MS', sans-serif; font-size: 1.2em;}
span.underline {text-decoration:underline; }
table.Table6 {width:14.487cm; }
div.Table6 {width: 100%; margin: 0px; padding: 0px; }
th.Table6_A1, td.Table6_A1 {border:none; padding:0.097cm; }
th.Table6_B1, td.Table6_B1 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:0.018cm solid #000000; padding:0.097cm; }
th.Table6_E1, td.Table6_E1 {border:0.018cm solid #000000; padding:0.097cm; }
table.Table8 {width:14.601cm; }
div.Table8 {width: 100%; margin: 0px; padding: 0px; }
th.Table8_A1, td.Table8_A1 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:0.018cm solid #000000; padding:0.097cm; }
th.Table8_D1, td.Table8_D1 {border:0.018cm solid #000000; padding:0.097cm; }
th.Table8_A2, td.Table8_A2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:none; padding:0.097cm; }
th.Table8_D2, td.Table8_D2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:0.018cm solid #000000; border-top:none; padding:0.097cm; }
table.Table9 {margin-left:0.6cm; margin-right:2.051cm; width:11.95cm; }
div.Table9 {width: 100%; margin: 0px; padding: 0px; }
th.Table9_A1, td.Table9_A1 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:0.018cm solid #000000; padding:0.097cm; }
th.Table9_C1, td.Table9_C1 {border:0.018cm solid #000000; padding:0.097cm; }
th.Table9_A2, td.Table9_A2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:none; padding:0.097cm; }
th.Table9_C2, td.Table9_C2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:0.018cm solid #000000; border-top:none; padding:0.097cm; }
table.Table10 {margin-left:0.6cm; margin-right:9.019cm; width:4.983cm; }
div.Table10 {width: 100%; margin: 0px; padding: 0px; }
th.Table10_A1, td.Table10_A1 {border:none; padding-bottom:0.101cm; padding-left:0cm; padding-right:0cm; padding-top:0.101cm; }
table.Table12 {keep-with-next:always; width:14.601cm; }
div.Table12 {width: 100%; margin: 0px; padding: 0px; }
th.Table12_A1, td.Table12_A1 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:0.018cm solid #000000; padding:0.097cm; }
th.Table12_D1, td.Table12_D1 {border:0.018cm solid #000000; padding:0.097cm; }
th.Table12_A2, td.Table12_A2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:none; border-top:none; padding:0.097cm; }
th.Table12_D2, td.Table12_D2 {border-bottom:0.018cm solid #000000; border-left:0.018cm solid #000000; border-right:0.018cm solid #000000; border-top:none; padding:0.097cm; }
table.Table13 {width:14.601cm; }
div.Table13 {width: 100%; margin: 0px; padding: 0px; }
span.Table13_1 {keep-together:always; }
th.Table13_A1, td.Table13_A1 {border:none; padding:0cm; }
table.Table30 {width:14.601cm; }
div.Table30 {width: 100%; margin: 0px; padding: 0px; }
span.Table30_1 {keep-together:always; }
th.Table30_A1, td.Table30_A1 {border:none; padding:0cm; }
table.Table7 {width:14.601cm; }
div.Table7 {width: 100%; margin: 0px; padding: 0px; }
span.Table7_1 {keep-together:always; }
th.Table7_A1, td.Table7_A1 {border:none; padding:0cm; }
table.Table11 {width:14.601cm; }
div.Table11 {width: 100%; margin: 0px; padding: 0px; }
span.Table11_1 {keep-together:always; }
th.Table11_A1, td.Table11_A1 {border:none; padding:0cm; }
Header_20_right.P1 {margin-bottom:0cm; margin-top:0cm; }
Header_20_left.P3 {font-weight:normal; }
li1b.P4 {keep-together:always; keep-with-next:always; }
p.P5 {keep-together:always; keep-with-next:always; }
h1.P6 {keep-together:always; keep-with-next:always; }
p.P7 {keep-with-next:always; }
p.P10 {break-after:auto; }</style></head><body><h1><a id="id2" name="id2"><!--id2--></a>Overview</h1><p><a href="http://localhost:8000/rep.test-content/packages/ele_1301_s1/media/resources/cmap/stored_prog_design.html">Stored program design (concept map)</a></p><p><a href="http://localhost:8000/rep.test-content/packages/ele_1301_s1/media/resources/cmap/ass_lang_prog.html">Assembly language programming (concept map)</a></p><h1><a id="id3" name="id3"><!--id3--></a>Objectives</h1><p class="P5">At the completion of this module you will be able to:</p><ul class="lib"><li><p>define software and define its use in applications, support and system programs</p></li><li><p>explain the concept of an assembler and how it may be used to develop a program for a microprocessor</p></li><li><p>explain the operation and features of the THRSim11 simulator software</p></li><li><p>state the purpose of a simulator program.<br/></p></li></ul><h1><a id="id5" name="id5"><!--id5--></a>12.1 Software</h1><h2><a id="id6" name="id6"><!--id6--></a>12.1.1 Introduction</h2><p>Software is the term coined to describe the programs or set of instructions that <span class="spCh spChx2018">&#x2018;</span>run<span class="spCh spChx2019">&#x2019;</span> the computer hardware. It is termed <span class="spCh spChx2018">&#x2018;</span>software<span class="spCh spChx2019">&#x2019;</span> because traditionally it has been stored in a storage medium which allows easy alteration and modification without the change of any physical components. The introduction of ROM (read only memory) has altered this criteria slightly since programs held in ROM are permanent and unalterable. Once a program is held in ROM it could be argued that it comprises part of the <span class="spCh spChx2018">&#x2018;</span>hardware<span class="spCh spChx2019">&#x2019;</span> instead of the <span class="spCh spChx2018">&#x2018;</span>software<span class="spCh spChx2019">&#x2019;</span>. When ROM is used to store programs, that program is often referred to as <b>firmware.</b></p><p>Generally software can be split into three areas. These are:</p><ul class="lib"><li><p>applications software</p></li><li><p>support software</p></li><li><p>system software.<br/></p></li></ul><p>Each of these areas will be discussed below but it should be realised that the application for which the computer is to be used will determine whether or not all three or only selected areas will exist with a particular system.</p><h2><a id="id7" name="id7"><!--id7--></a>12.1.2 Applications software</h2><p>These are the programs which make the computer perform a specific task for which it has been purchased. The programs written for dedicated microprocessor applications are <span class="spCh spChx2018">&#x2018;</span>Applications software<span class="spCh spChx2019">&#x2019;</span>, e.g. process control applications, data loggers, etc.</p><p>Such programs are usually machine dependent in that they are designed with a particular computer in mind and use the special features it provides, e.g. interrupt handling facilities. <span class="spCh spChx2018">&#x2018;</span>Application programs<span class="spCh spChx2019">&#x2019;</span> once debugged and tested are usually stored in machine language form in ROM.</p><p>The majority of microprocessor based dedicated systems run <span class="spCh spChx2018">&#x2018;</span>applications software<span class="spCh spChx2019">&#x2019;</span> exclusively. Some applications which require higher operating speed or extensive computation may use mini-computer based systems.</p><h2><a id="id8" name="id8"><!--id8--></a>12.1.3 Support software</h2><p>When developing <span class="spCh spChx2018">&#x2018;</span>Application Programs<span class="spCh spChx2019">&#x2019;</span> it is virtually essential to provide development aides to the programmer. Programs which fall into this category are called <b>support software</b>. Programs developed, supplied and supported by the computer manufacturer for a particular make and type of machine which help in writing and testing <span class="spCh spChx2018">&#x2018;</span>application programs<span class="spCh spChx2019">&#x2019;</span> are classed as <span class="spCh spChx2018">&#x2018;</span>support software<span class="spCh spChx2019">&#x2019;</span>.</p><p>The most obvious examples are assemblers, compilers, text editors for typing in and correcting programs.</p><p>A second type of support software is available as packages of machine code subroutines which can be introduced as blocks of code into application programs. Typical examples are mathematical routines; e.g. floating point arithmetic, multiplication, division, trigonometric functions etc.; I/O handling and conversion routines, e.g. conversion from binary numbers to a string of ASCII characters etc. These packages are available to the programmer for inclusion in his application program and are known as utility routines.</p><p>In the microprocessor range two examples exist. The first is the <span class="spCh spChx2018">&#x2018;</span>microprocessor development system<span class="spCh spChx2019">&#x2019;</span>, which is designed to provide support for one microprocessor. Briefly this provides an editing facility for entering and changing the text of the program, an assembler or in some cases a compiler to translate the source code (program entered in assembler or higher level language) into object code (i.e. machine code), a simulator which is a program that <span class="spCh spChx2018">&#x2018;</span>simulates<span class="spCh spChx2019">&#x2019;</span> the CPU operation and checks the program operation and a PROM programmer to store the debugged program in PROM. This system is used purely for Software Development.</p><p>The second example is the desktop microcomputer, which is based on a microprocessor system that runs <b>compiled</b> programs and may include an <b>interpreter</b>.</p><p>Such systems often can only be programmed in the high level language supported by the Compiler/Interpreter software, e.g. <b>Visual Basic</b>. An Interpreter may be considered part of the <span class="spCh spChx2018">&#x2018;</span>applications program<span class="spCh spChx2019">&#x2019;</span> since both must operate together to provide useful program execution.</p><p>Microcomputer based systems extend across a broad range. At one end of the spectrum there is the stand-alone microcomputer used to run application type programs but with support facilities in the form of a word processor, assembler and compiler for developing its own applications programs.</p><p>At the other extreme there are microcomputer network systems used extensively for multi-user operation with multiple support systems. This server/client type system can run applications programs such as payroll, student records, etc. as well as providing software development aides to develop these and other programs along with providing an extensive range of utility packages.</p><h2><a id="id9" name="id9"><!--id9--></a>12.1.4 System software</h2><p>System Software is reserved for use on larger computer systems which have several I/O devices and a large number of support programs and packages usually stored on magnetic disc or tape. The system may be single user but more usually it is a multi-user system.</p><p>Any user developing his application program to run on this system (e.g. a <span class="spCh spChx2018">&#x2018;</span>payroll program<span class="spCh spChx2019">&#x2019;</span> or <span class="spCh spChx2018">&#x2018;</span>structural analysis program<span class="spCh spChx2019">&#x2019;</span>) can write it so that it performs every task required of the computer. Many tasks such as file handling on disc or tape or timing control sequence for a particular I/O device do not differ from one application to the next. Such tasks can be provided by the system and are provided each time a system task is requested. Thus software, which is dedicated to the running and organising the computer system in a wider supervisory sense is classed as system software. In controlling the general operation of the computer system, the system software frees the application programs from standard system tasks.</p><p>A special system program called the <b>executive</b> program manages the complete computer system and organises the allocation of all resources provided by the system between the multiple users, i.e. allocates I/O devices, memory, system software, support software, etc.</p><p>The system executive and the supporting system software is referred to as the <b>operating system</b>.</p><p>The function of the <span class="spCh spChx2018">&#x2018;</span>operating system<span class="spCh spChx2019">&#x2019;</span> in a multi-user system is as follows:</p><ul class="lib"><li><p><b>Processor scheduling</b> <span class="spCh spChx2013">&#x2013;</span> Allocation of processing time to <span class="spCh spChx2018">&#x2018;</span>jobs<span class="spCh spChx2019">&#x2019;</span> waiting to be run. Various techniques can be employed. One method is to run each job (i.e. program) for a fixed period called a <b><span class="spCh spChx2018">&#x2018;</span>time slice<span class="spCh spChx2019">&#x2019;</span></b>. If the program completes within this period the job is complete, if the job is not complete it returns to the queue of jobs awaiting processing. Similarly if the program requires access to an I/O device which is being used elsewhere it is placed in another queue awaiting the availability of that device.</p><p>The aim of the <span class="spCh spChx2018">&#x2018;</span>processor scheduling<span class="spCh spChx2019">&#x2019;</span> is to get the maximum program throughout without large programs <span class="spCh spChx2018">&#x2018;</span>hogging<span class="spCh spChx2019">&#x2019;</span> the system at the expense of small programs or longer programs being equally well <span class="spCh spChx2018">&#x2018;</span>stalled<span class="spCh spChx2019">&#x2019;</span> by smaller programs.</p></li><li><p><b>Job scheduling</b> <span class="spCh spChx2013">&#x2013;</span> Allocation of jobs awaiting processing. Normally a large computer system has multiple users each with a different <span class="spCh spChx2018">&#x2018;</span>priority<span class="spCh spChx2019">&#x2019;</span>. The <span class="spCh spChx2018">&#x2018;</span>job scheduler<span class="spCh spChx2019">&#x2019;</span> will organise the queue of jobs according to priority. Jobs can be organised in <b>batch mode</b> where programs are run overnight at the convenience of the system or <b>interactive mode</b> where the actual user is requesting program execution immediately and is waiting for the results <b>on-line</b>.</p></li><li><p><b>Resource management</b> <span class="spCh spChx2013">&#x2013;</span> This is the general term used here to include</p><ul class="lib"><li><p>allocation of support programs as requested</p></li><li><p>allocation of I/O devices and related system software</p></li><li><p>allocation of memory space for jobs in process</p></li><li><p>transfer of programs between main memory and backing store, i.e. magnetic disc/tape.<br/></p></li></ul></li></ul><p>All large computer systems based on microcomputer and main frame computers have an operating system. The complexity and major features provided varies considerably and is closely related to price. The cost of the system software often exceeds the cost of the hardware alone.</p><p>Unfortunately time does not permit a full consideration of the complete computer range together with details of the software systems as categorised above.</p><p>In the time available in this course our attention will be restricted to the major features of the assembler and the software developments for microprocessor based systems.</p><p class="P10"/><div class="Table30" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table30 selfassessment" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:2.002cm;"/><col style="width:12.599cm;"/></colgroup><tbody><tr><td class="Table30_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p><a name="graphics25"><!-- --></a><img alt="graphics25" class="fr1" height="57" src="module12_files/74f1452e_57x57.jpg" style="border:0px; vertical-align: top" width="57"/></p></td><td class="Table30_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><h6><a id="id10" name="id10"><!--id10--></a><span class="T1">Self assessment </span><span class="T1">12.1</span></h6><ol class="lin" style="list-style: decimal;"><li><p>What is computer software?</p></li><li><p>How is system software different from application software?</p></li></ol></td></tr></tbody></table></div><p/><h1><a id="id11" name="id11"><!--id11--></a>12.2 Assemblers</h1><h2><a id="id12" name="id12"><!--id12--></a>12.2.1 Introduction</h2><p>The basic purpose of an assembler is to translate assembly language mnemonics into binary machine language code (source code or opcode). An assembler is a software program, which runs on a host computer. Most assemblers offer: labelling, comments and symbol tables.</p><p>Assembler statements consist of <span class="spCh spChx2018">&#x2018;</span>fields<span class="spCh spChx2019">&#x2019;</span></p><div class="Table6" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table6" style="border-spacing: 0;empty-cells: show; width:14.487cm; border-collapse: collapse; "><colgroup><col style="width:5.535cm;"/><col style="width:1.984cm;"/><col style="width:2.469cm;"/><col style="width:2.028cm;"/><col style="width:2.469cm;"/></colgroup><tbody><tr><td class="Table6_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p>i.e. </p></td><td class="Table6_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p>Label</p></td><td class="Table6_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p>Mnemonics</p></td><td class="Table6_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p>Operand</p></td><td class="Table6_E1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p>Comment</p></td></tr></tbody></table></div><p/><p>Most microprocessor assemblers use what is called <span class="spCh spChx2018">&#x2018;</span>free formatting<span class="spCh spChx2019">&#x2019;</span> which means the individual fields can be separated by a <span class="spCh spChx2018">&#x2018;</span>delimiter<span class="spCh spChx2019">&#x2019;</span> put there by the programmer. Typical delimiters are the space, colon, slash and comma.</p><h2><a id="id13" name="id13"><!--id13--></a>12.2.2 Assembler fields</h2><p>The first field is the label field. Labels should be used often and most assemblers will allow a certain number of characters per label such as six or eight. Labels assist in understanding the algorithms used by a particular programmer to solve a problem.</p><p>The next field is the mnemonic field. Normal mnemonics are used in this field and it is the only field which <b>must</b> have an entry in every line.</p><p>The assembler software simply compares the operation code with a <span class="spCh spChx2018">&#x2018;</span>lookup table<span class="spCh spChx2019">&#x2019;</span> until it finds a match. The match will then yield the <b>binary code</b> for that particular mnemonic.</p><p>These lookup tables are usually stored in a read only memory.</p><h2><a id="id14" name="id14"><!--id14--></a>12.2.3 Pseudo operations</h2><p>These are <b>directives</b> to the assembler only and are ignored by the computer itself. They appear in the mnemonic field but are not translated into binary code.</p><p>They may assign program and data to areas of memory, define symbols, allocate space for variables, generate fixed tables or mark the end of a program. Typical examples are: origin (ORG), equate (EQU), reserve (RES), data (DAT), end (END).</p><h2><a id="id15" name="id15"><!--id15--></a>12.2.4 Example</h2><p>To assist with the understanding of an assembler operation, consider the following example:</p><div class="Table8" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table8" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; border: 1.0px solid #000000"><colgroup><col style="width:3.649cm;"/><col style="width:3.651cm;"/></colgroup><tbody><tr><td class="Table8_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Label field</p></td><td class="Table8_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Mnemonic field</p></td><td class="Table8_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Operand field</p></td><td class="Table8_D1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center">Comment field</p></td></tr><tr><td class="Table8_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">BILL<br/>JACK<br/><br/>START<br/><br/><br/><br/><br/><br/><br/><br/>HERE<br/><br/></p></td><td class="Table8_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">EQU<br/>EQU<br/>ORG<br/>LDA<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span><br/>DECA<br/>BEQ<br/>LDAA<br/>BPL<br/>NEGA<br/>CMPA<br/><span class="spCh spChx201c">&#x201C;</span><br/>etc.</p></td><td class="Table8_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">$0000<br/>$0001<br/>$0010<br/>#$50<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span><br/><br/>START<br/>BILL<br/>HERE<br/><br/>JACK<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span></p></td><td class="Table8_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p><br/><br/><br/>Set Counter<br/><br/><br/>Decrement count<br/>If zero go to START<br/>Get Bill<br/>is it -ve<br/>Yes <span class="T2"><span class="spCh spChx2192">&#x2192;</span></span> negate<br/><br/><br/></p></td></tr></tbody></table></div><p/><p>The assembler is to code this program into machine code. Designed into the assembler is a table which contains the following:</p><div class="Table9" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table9" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:2.051cm; width:11.95cm; border-collapse: collapse; border: 1.0px solid #000000"><colgroup><col style="width:3.969cm;"/><col style="width:4.036cm;"/><col style="width:3.946cm;"/></colgroup><tbody><tr><td class="Table9_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Mnemonic</p></td><td class="Table9_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Machine code<br/>in hex</p></td><td class="Table9_C1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center">Instruction length<br/>(bytes)</p></td></tr><tr><td class="Table9_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">ADDA #<br/>CLRA<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span></p></td><td class="Table9_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">8B<br/>4F<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span></p></td><td class="Table9_C2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p class="center">2<br/>1<br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span><br/><span class="spCh spChx201c">&#x201C;</span></p></td></tr></tbody></table></div><p/><p>This allows the assembler to examine the <b>mnemonic field</b> and the <span class="spCh spChx2018">&#x2018;</span>address mode<span class="spCh spChx2019">&#x2019;</span> and code the program by <span class="spCh spChx2018">&#x2018;</span>table look up<span class="spCh spChx2019">&#x2019;</span> methods.</p><p>Because <span class="spCh spChx2018">&#x2018;</span>symbols<span class="spCh spChx2019">&#x2019;</span> or <span class="spCh spChx2018">&#x2018;</span>labels<span class="spCh spChx2019">&#x2019;</span> are convenient for use when writing assembly language programs, the assembler must keep track of these and insert the preset values or calculate the <span class="spCh spChx2018">&#x2018;</span>offsets<span class="spCh spChx2019">&#x2019;</span> accordingly.</p><p>This initially looks simple enough, the assembler scans the program a line at a time and</p><ul class="lib"><li><p>keeps track of the <span class="spCh spChx2018">&#x2018;</span>memory address<span class="spCh spChx2019">&#x2019;</span> occupied by each instruction. This is done by setting a <span class="spCh spChx2018">&#x2018;</span><b>location counter</b><span class="spCh spChx2019">&#x2019;</span> to the value set by the <span class="spCh spChx2018">&#x2018;</span>ORG<span class="spCh spChx2019">&#x2019;</span> statement and incrementing it for each instruction according to the Instruction Length given in the <b>mnemonic table</b>.</p></li><li><p>constructs a <b>symbol table</b> of entries in the label field. When a <span class="spCh spChx2018">&#x2018;</span>symbol or label<span class="spCh spChx2019">&#x2019;</span> is encountered in the <span class="spCh spChx2018">&#x2018;</span>Label Field<span class="spCh spChx2019">&#x2019;</span> it is entered in the symbol table together with the value it is assigned for <span class="spCh spChx2018">&#x2018;</span>EQU directives<span class="spCh spChx2019">&#x2019;</span> or the value of the <span class="spCh spChx2018">&#x2018;</span>Location Counter<span class="spCh spChx2019">&#x2019;</span> elsewhere in the program.</p><div class="Table10" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table10" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:9.019cm; width:4.983cm; border-collapse: collapse; "><colgroup><col style="width:0.97cm;"/><col style="width:2.028cm;"/><col style="width:1.984cm;"/></colgroup><tbody><tr><td class="Table10_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>e.g.</p></td><td class="Table10_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>BILL<br/>JACK<br/>START<br/>etc.</p></td><td class="Table10_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>$0000<br/>$0001<br/>$0010</p></td></tr></tbody></table></div><p/></li><li><p>Coding the program directly into machine code can now proceed a line at a time as it is entered.</p><p>When a <span class="spCh spChx2018">&#x2018;</span>label/symbol<span class="spCh spChx2019">&#x2019;</span> is encountered in the <span class="spCh spChx2018">&#x2018;</span>operand field<span class="spCh spChx2019">&#x2019;</span>, e.g. as in <span class="spCh spChx2018">&#x2018;</span>BEQ START<span class="spCh spChx2019">&#x2019;</span>, the address or value assigned to that symbol is obtained from the <b>symbol</b> table.</p><p>i.e. The assembler determines that START = $0010 and from this value and that of the location counter it can calculate the <span class="spCh spChx2018">&#x2018;</span>offset<span class="spCh spChx2019">&#x2019;</span> for the <span class="spCh spChx2018">&#x2018;</span>BEQ<span class="spCh spChx2019">&#x2019;</span> instruction.<br/><b>Note:</b> The Assembler ignores all comments in the comment field.</p><p>This procedure works well until the <span class="spCh spChx2018">&#x2018;</span>BPL HERE<span class="spCh spChx2019">&#x2019;</span> instruction is encountered. Because the Label <span class="spCh spChx2018">&#x2018;</span>HERE<span class="spCh spChx2019">&#x2019;</span> has not been reached yet in the <span class="spCh spChx2018">&#x2018;</span>label field<span class="spCh spChx2019">&#x2019;</span>, there is no entry for it in the <b>symbol</b> table and direct translation into machine code cannot continue. This is called the <b>forward reference</b> problem and is the reason for having a 2-pass assembler.</p></li></ul><p>In a 2-pass assembler, on the <b>first pass</b>, i.e. the first time the program is run through the assembler, a complete <b>symbol table</b> is constructed. The way this is achieved is shown in the following flowchart.</p><p class="P7">First PASS</p><p><a name="graphics3"><!-- --></a><img alt="graphics3" class="fr1" height="620" src="module12_files/15d9c2b2_528x620.jpg" style="border:0px; vertical-align: top" width="528"/></p><p>Note: The only assembler directives illustrated here are END, EQU and ORG.</p><p>At the completion of PASS 1 all the symbols used will have an entry and an assigned value in, the <b>symbol table</b>.</p><p>On PASS 2 the program can now be scanned a line at a time and coded directly into machine code. When a label or symbol is encountered in the operand field its value can simply be determined from the <b>symbol table</b> and the translation continued.</p><p>It is possible to have a one-pass assembler, however, these are complex and require a large memory space. In PASS 2 of a two-pass system, as the line is scanned and the code produced the machine code can be output directly onto file. In PASS 1 only the symbol table has to be stored. In a one-pass system the complete coded program has to be stored with special features to <span class="spCh spChx2018">&#x2018;</span>mark<span class="spCh spChx2019">&#x2019;</span> where the forward reference problem occurred. At the conclusion of reading in the source program (i.e. assembly language program) the assembler can then return to insert the correct values for each <span class="spCh spChx2018">&#x2018;</span><b>mark</b><span class="spCh spChx2019">&#x2019;</span> and finally output the machine language program (i.e. object code).</p><p class="P10"/><div class="Table7" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table7 selfassessment" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:2.002cm;"/><col style="width:12.599cm;"/></colgroup><tbody><tr><td class="Table7_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p><a name="graphics1"><!-- --></a><img alt="graphics1" class="fr1" height="57" src="module12_files/74f1452e_57x57.jpg" style="border:0px; vertical-align: top" width="57"/></p></td><td class="Table7_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><h6><a id="id16" name="id16"><!--id16--></a><span class="T1">Self assessment </span><span class="T1">12.2</span></h6><ol class="lin" style="list-style: decimal;"><li><p>What is the purpose of an assembler program?</p></li><li><p>How does assembly language differ from machine language?</p></li></ol></td></tr></tbody></table></div><p/><h1><a id="id17" name="id17"><!--id17--></a>12.3 Software development for microprocessors</h1><h2><a id="id18" name="id18"><!--id18--></a>12.3.1 Introduction</h2><p>To assist in the development of software for a specific microprocessor, manufacturers often produce development kits. These kits provide sufficient hardware and software to enable the developer to program and test the application software. Typically, development kits include a microprocessor board that includes a serial interface and LED display, management software to run on the host computer (the assembler/debugger), and an interface cable to connect the microprocessor board to the host computer.</p><p>With the development kit connected to the host computer, a program can be written on the host in assembly language then assembled into machine code, and the machine code then downloaded to the development kit where it can be run. Some advanced assemblers provide debugging facilities, allowing the developer to monitor microprocessor registers, etc as the program runs. The THRSim11 software interfaced to the EZ-micro development board is a typical example.</p><h2><a id="id19" name="id19"><!--id19--></a>12.3.2 The THRSim11 simulator</h2><p>The following text is an extract from the THRSim11 website, <br/>&lt;http://www.hc11.demon.nl/thrsim11/thrsim11.htm&gt;.</p><p><i>The Motorola 68HC11 microcontroller is a popular microcontroller used in many applications. With the THRSim11 program you can edit, assemble, simulate and debug programs for the 68HC11 on your windows PC. You can also use THRSim11 to debug the program on your target EVM or EVB compatable board. The simulator simulates the CPU, ROM, RAM, and all memory mapped I/O ports. It also simulates the on board peripherals such as: </i></p><ul class="lib"><li><p><i>timer (including pulse accumulator), </i></p></li><li><p><i>analog to digital converter, </i></p></li><li><p><i>parallel ports (including handshake), </i></p></li><li><p><i>serial port, </i></p></li><li><p><i>I/O pins (including analog and interrupt pins).<br/></i></p></li></ul><p><i>While debugging the graphical user interface makes it possible to view and control every register (CPU registers and I/O registers), memory location (data, program, and stack), and pin of the simulated microcontroller. Even when the program is running! It is possible to stop the simulation at any combination of events. For example: stop when RxD becomes low and RAM location $003F contains $BD or I/O register TCNT is greater than $3456. </i></p><p><i>A number of (simulated) external components can be connected to the pins of the simulated 68HC11 while debugging. For example:</i></p><ul class="lib"><li><p><i>LED's, </i></p></li><li><p><i>switches, </i></p></li><li><p><i>analog sliders (variable voltage potential). </i></p></li><li><p><i>serial transmitter and receiver. </i></p></li><li><p><i>many more... see the THRSim11 components page.<br/></i></p></li></ul><p><i>There is also a 4 x 20 LCD character display mapped in the address space of the 68HC11.</i></p><p><i>THRSim11 can communicate with the Motorola EVM and EVB boards or with any other board running the BUFFALO monitor program. When your assembly program is loaded into the target board the graphical user interface makes it possible to view and control every register (CPU registers and I/O registers) and memory location (data, program, and stack) of the real microcontroller. It is possible to stop the execution at any address and inspect or change the registers and memory.</i></p><p>This software will be used to program and simulate the operation of the 68HC11 microcontroller.  The software and installation instructions are provided to you on the resource CD included in this study package.</p><p>All program examples which are provided hereafter are able to be assembled and simulated using this software.</p><p class="P7"><a name="graphics4"><!-- --></a><img alt="graphics4" class="fr2" height="415" src="module12_files/m6d50d8be_552x415.jpg" style="border:0px; vertical-align: top" width="552"/></p><blockquote class="bqs"><p>(Source: THRSimm11 simulator software)</p></blockquote><p class="figure-caption-below"><b>Figure </b><b>12</b><b>.</b><b>1</b><b>:</b> The THRSim11 graphical user interfave</p><h2><a id="id20" name="id20"><!--id20--></a>12.3.3 Example program</h2><p>The program is created by selecting <span class="spCh spChx2018">&#x2018;</span>New<span class="spCh spChx2019">&#x2019;</span> from the <span class="spCh spChx2018">&#x2018;</span>File<span class="spCh spChx2019">&#x2019;</span> menu. The program is divided into a set of <span class="spCh spChx2018">&#x2018;</span>fields<span class="spCh spChx2019">&#x2019;</span> as we have seen in previous work and, although not shown on the screen, they are named as shown below. Note that each field is separated by a field delimiter, in this case the <span class="spCh spChx2018">&#x2018;</span>Tab<span class="spCh spChx2019">&#x2019;</span> key.</p><p>When typing in a program you must define your data and any special areas of memory first. This is achieved using <span class="spCh spChx2018">&#x2018;</span><b>directives or pseudo mnemonics</b><span class="spCh spChx2019">&#x2019;</span>.</p><div class="Table12" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table12" style="border-spacing: 0;empty-cells: show; keep-with-next:always; width:14.601cm; border-collapse: collapse; border: 1.0px solid #000000"><colgroup><col style="width:2.073cm;"/><col style="width:2.558cm;"/><col style="width:3.881cm;"/><col style="width:6.091cm;"/></colgroup><tbody><tr><td class="Table12_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p><b>Pseudo mnemonic</b></p></td><td class="Table12_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p><b>Meaning</b></p></td><td class="Table12_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p><b>Usage</b></p></td><td class="Table12_D1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p><b>Definition definition</b></p></td></tr><tr><td class="Table12_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p>EQU<br/>ORG<br/><br/><br/>FCB<br/><br/><br/>RMB<br/><br/>PAGE</p></td><td class="Table12_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p>equate<br/>origin<br/><br/><br/>form&#xA0;constant<br/>byte<br/><br/>reserve<br/>memory byte<br/>paginate</p></td><td class="Table12_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p>BUFFER&#xA0;EQU&#xA0;$1200<br/>ORG $0010<br/><br/><br/>FCB $09<br/>FCB $0976<br/>FCB $A045FF <br/>DATA RMB n<br/><br/>PAGE</p></td><td class="Table12_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>defines the value of a label<br/>sets starting address of next byte<br/>of code<br/><br/>makes next byte=$09<br/>makes next two bytes =$0976<br/>makes&#xA0;next&#xA0;three&#xA0;bytes&#xA0;=&#xA0;$A045FF<br/>leaves a decimal n byte gap in<br/>code for later use<br/>instruction for use by printout<br/>routine only.<br/>Forces page-break in listing.</p></td></tr></tbody></table></div><p/><p>In this example we will use the basic program we have developed and coded previously. That is, developing a program to execute the problem: 9 - 5 + 2 = ANS. As before we will give the numbers 9, 5 and 2 labels as NUM 1, NUM2 and NUM3 respectively, and the result will be stored in the location labelled as ANS.</p><h3><a id="id21" name="id21"><!--id21--></a>Editor listing</h3><p><a name="graphics5"><!-- --></a><img alt="graphics5" class="fr2" height="313" src="module12_files/63b9e0ed_545x313.jpg" style="border:0px; vertical-align: top" width="545"/></p><p>Note the use of <span class="spCh spChx2018">&#x2018;</span>ORG<span class="spCh spChx2019">&#x2019;</span> to define the starting address at location $0000 for data and $E000 for the program.</p><p>If the display is satisfactory then the appropriate SAVE option is chosen from the <span class="spCh spChx2018">&#x2018;</span>File<span class="spCh spChx2019">&#x2019;</span> menu.</p><p>The program is then be assembled by selecting <span class="spCh spChx2018">&#x2018;</span>Assemble<span class="spCh spChx2019">&#x2019;</span> from the <span class="spCh spChx2018">&#x2018;</span>File<span class="spCh spChx2019">&#x2019;</span> menu. Assembly will then occur and if any errors are present, they will be reported on the screen.</p><p>If there are no errors, the assembler output will appear in a new dialogue box. The following is an example of the assembler output.</p><p><a name="graphics7"><!-- --></a><img alt="graphics7" class="fr2" height="255" src="module12_files/m413d566c_547x255.jpg" style="border:0px; vertical-align: top" width="547"/></p><p>Once the program is assembled it can be simulated by selecting <span class="spCh spChx2018">&#x2018;</span>Run<span class="spCh spChx2019">&#x2019;</span> from the <span class="spCh spChx2018">&#x2018;</span>Execute<span class="spCh spChx2019">&#x2019;</span> menu.  Toolbar buttons are also available for these functions.</p><p class="table-caption-above"><b>Table </b><b>12</b><b>.</b><b>1</b><b>:</b> THRSim11 simulator default memory map</p><p><a name="graphics8"><!-- --></a><img alt="graphics8" class="fr1" height="382" src="module12_files/m23400b8c_547x382.jpg" style="border:0px; vertical-align: top" width="547"/></p><div class="Table13" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table13 learning" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:2.002cm;"/><col style="width:12.599cm;"/></colgroup><tbody><tr><td class="Table13_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p><a name="graphics9"><!-- --></a><img alt="graphics9" class="fr1" height="57" src="module12_files/m73656803_57x57.jpg" style="border:0px; vertical-align: top" width="57"/></p></td><td class="Table13_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><h6><a id="id22" name="id22"><!--id22--></a>Activity <span class="T1">12</span><span class="T1">.</span><span class="T1">1</span></h6><p>Refer to the ELE1301 course page on <span class="spCh spChx2018">&#x2018;</span>Study Desk<span class="spCh spChx2019">&#x2019;</span> and complete the following experiments:</p><ol class="lin" style="list-style: decimal;"><li><p>Home experiment 12-1 <span class="spCh spChx2013">&#x2013;</span> Introduction to the THRSim11 software</p></li><li><p>Home experiment 12-2 <span class="spCh spChx2013">&#x2013;</span> Introduction to assembly language programming.</p></li><li><p>Home experiment 12-3 <span class="spCh spChx2013">&#x2013;</span> Directives in assembly language programming</p></li><li><p>Home experiment 12-4 <span class="spCh spChx2013">&#x2013;</span> Introduction to program simulation.</p></li></ol></td></tr></tbody></table></div><p/><div class="Table11" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table11 selfassessment" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:2.002cm;"/><col style="width:12.599cm;"/></colgroup><tbody><tr><td class="Table11_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p><a name="graphics2"><!-- --></a><img alt="graphics2" class="fr1" height="57" src="module12_files/74f1452e_57x57.jpg" style="border:0px; vertical-align: top" width="57"/></p></td><td class="Table11_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><h6><a id="id23" name="id23"><!--id23--></a><span class="T1">Self assessment </span><span class="T1">12.3</span></h6><ol class="lin" style="list-style: decimal;"><li><p>Using the instruction set provided for the 68HC11 microcontroller, write a program that will sum the contents of memory addresses $0000 through $0004 and store the result in address $0005.  </p><ol class="li-lower-roman" style="list-style: lower-roman;"><li><p>Start the program at address $E000</p></li><li><p>Use indexed addressing to access the data</p></li><li><p>Add assembler directives as required</p></li><li><p>Set out the program using the following column heading.</p><p>Address   Opcode   Label   Mnemonic   Operand   Comments</p><p>Values to be summed:</p><p>$0000  -  $01</p><p>$0001  -  $02</p><p>$0002  -  $03</p><p>$0003  -  $04</p><p>$0004  -  $05</p></li></ol></li><li><p>Draw a flow chart for the above program.</p></li><li><p>Explain the operation of the above program.</p></li><li><p>Write a fully coded program, using the instruction set provided, to successively subtract the decimal number 15 from the decimal number 75 and when the result is negative store it to memory. Neatly set out your work to provide:</p><ol class="li-lower-roman" style="list-style: lower-roman;"><li><p>Flow chart</p></li><li><p>Memory map</p></li><li><p>Assembly language program</p></li><li><p>Machine coded program</p></li></ol></li></ol></td></tr></tbody></table></div><p/></body></html>
