<div><h1><a id="id2" name="id2"><!--id2--></a>Overview</h1><p>Modules 1 to 7 have been concerned with the basic building blocks for a digital computer. We will now use those blocks to construct a computer system.</p><p><a href="http://localhost:8000/rep.test-content/packages/ele_1301_s1/media/resources/cmap/micro_architecture.html">Microcomputer architecture (concept map)</a></p><h1><a id="id3" name="id3"><!--id3--></a>Objectives</h1><p class="P6">At the completion of his module you will be able to:</p><ul class="lib"><li><p>describe the basic modules used in a block diagram of a typical digital computer system</p></li><li><p>explain the operation of basic semi-conductor memory systems including RAM, ROM and EPROM</p></li><li><p>explain the operation of alternative memory systems including magnetic, optical and bubble memory devices</p></li><li><p>state the instructions to perform desired operations in a central processing unit (CPU)</p></li><li><p>explain the architecture and basic operation of an elementary CPU.<br/></p></li></ul><h1><a id="id5" name="id5"><!--id5--></a>8.1 Introduction to the microprocessor concept</h1><h2><a id="id6" name="id6"><!--id6--></a>8.1.1 Introduction</h2><p>A basic block diagram of a microcomputer system is shown:</p><p class="indent"><a name="graphics2"><!-- --></a><img alt="graphics2" class="fr1" height="192" src="module08_files/7eca4146_500x192.jpg" style="border:0px; vertical-align: top" width="500"/></p><p>Let us broadly consider these blocks.</p><h2><a id="id7" name="id7"><!--id7--></a>8.1.2 Input devices</h2><p>Input devices may be many and are generally familiar to everyone. They include keyboards, keypads, magnetic tapes and disks, analog-to-digital converters, touch screens, light pens, digitisers, character readers, scanners and even voice recognition systems.</p><h2><a id="id8" name="id8"><!--id8--></a>8.1.3 Output devices</h2><p>Output devices may similarly be many. They include printers, visual display units, digital-to-analog converters plasma and LCD screens, plotters, microfiche film and speech systems.</p><h2><a id="id9" name="id9"><!--id9--></a>8.1.4 The memory unit</h2><p>The memory unit is used to store information either temporarily or permanently.</p><p>Information stored is usually:</p><ul class="lib"><li><p>the operating program</p></li><li><p>the data to be used by the program.<br/></p></li></ul><p>A typical memory system is shown in the diagram:</p><p><a name="graphics3"><!-- --></a><img alt="graphics3" class="fr1" height="305" src="module08_files/35b2673a_547x305.jpg" style="border:0px; vertical-align: top" width="547"/></p><p>A memory consists of a fixed number of storage areas known as <b>locations</b>. Each location has a fixed number of <b>cells</b>. Each cell holds one <b>bit</b> of information. A common number of cells per location is eight. However this may be 16, 32 or 64 depending upon the application. If we consider one location in an 8 bit memory the usual representation is to draw it as shown:</p><div class="Table7" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table7" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:2.492cm; width:11.509cm; border-collapse: collapse; "><colgroup><col style="width:2.469cm;"/><col style="width:1.037cm;"/><col style="width:1.014cm;"/><col style="width:0.97cm;"/><col style="width:0.991cm;"/><col style="width:1.014cm;"/><col style="width:1.037cm;"/><col style="width:0.991cm;"/><col style="width:0.97cm;"/><col style="width:1.014cm;"/></colgroup><tbody><tr><td class="Table7_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="P10">Location 0</p></td><td class="Table7_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="P11">=</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">1</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">0</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">0</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">1</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">0</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">0</p></td><td class="Table7_C1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="P10">1</p></td><td class="Table7_J1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="P10">0</p></td></tr></tbody></table></div><p/><p>The location has 8 bits and this is referred to as one <b>byte</b> of information. An eight bit byte is composed of two 4 bit <b>nibbles</b>.</p><p>Each location is identified by a unique <b>address</b>.</p><p class="P9">To store information in the memory the central processor first defines the appropriate memory location by specifying a binary number to an address decoder. The processor then sends the required information to the memory block and at the same time, sends a control command to <span class="spCh spChx2018">&#x2018;</span>write<span class="spCh spChx2019">&#x2019;</span> the information into memory.</p><h2><a id="id10" name="id10"><!--id10--></a>8.1.5 Practical memory systems</h2><p>In many memory systems the basic element used to create a <span class="spCh spChx2018">&#x2018;</span>cell<span class="spCh spChx2019">&#x2019;</span> is the flip flop. When the flip flop has its Q output set to a logic 1 by the application of a pulse to its set (s) input, it is said to have stored a logic 1 as it remains set after the setting pulse has been removed. Vast arrays of flip flops are used for memories.</p><p>This type of memory is called <span class="spCh spChx2018">&#x2018;</span>Static RAM<span class="spCh spChx2019">&#x2019;</span> (SRAM), where RAM stands for <span class="spCh spChx2018">&#x2018;</span>random access memory<span class="spCh spChx2019">&#x2019;</span>. As mentioned previously the basic semiconductor element used is the SR bistable and it is used in the configuration as shown below:</p><p><a name="graphics4"><!-- --></a><img alt="graphics4" class="fr1" height="168" src="module08_files/294aff5b_448x168.jpg" style="border:0px; vertical-align: top" width="448"/></p><p>To reset this bistable R is made a 1 which stores (puts in memory) a zero, effectively clearing that location.</p><p>The input is via a 2 input NAND gate. One input, say S<sub>1</sub>, is called the select or <b>enable </b>line and when it is made a 1, the FF can be set with a 1 on the S<sub>2</sub> line.</p><p>Note with this memory element, the signal at either of the Q or <a name="Object1"><!-- --></a><img alt="Object1" class="fr2" height="24" src="module08_files/28251b81_16x24bw.png" style="border:0px; vertical-align: middle" width="16"/> lines can be measured or sensed as often as desired without affecting or destroying the logic signals.</p><p>These semiconductor memories are called <span class="spCh spChx2018">&#x2018;</span>non-destructive read-out<span class="spCh spChx2019">&#x2019;</span> memories. However if the supply power is removed or lost accidentally, the Q and <a name="Object2"><!-- --></a><img alt="Object2" class="fr2" height="24" src="module08_files/28251b81_16x24bw.png" style="border:0px; vertical-align: middle" width="16"/> signals go to zero and when power is restored, general circuit noise will randomly set Q or <a name="Object3"><!-- --></a><img alt="Object3" class="fr2" height="24" src="module08_files/28251b81_16x24bw.png" style="border:0px; vertical-align: middle" width="16"/> to either a 1 or a 0. We have however, lost the stored information.</p><p>This SR element is also called <span class="spCh spChx2018">&#x2018;</span>volatile memory<span class="spCh spChx2019">&#x2019;</span> for this reason. The problem is sometimes overcome by using a set of batteries permanently connected to the memory element. This is called <span class="spCh spChx2018">&#x2018;</span>battery-backed<span class="spCh spChx2019">&#x2019;</span> memory.</p><p>The SR circuit is the basis for the semi-conductor memory called a Random Access Memory (RAM), (or read-write memory or scratch-pad memory).</p><p class="P9">A typical RAM uses several bistables (cells) in a matrix format as shown:</p><p><a name="graphics5"><!-- --></a><img alt="graphics5" class="fr1" height="206" src="module08_files/m440c0426_547x206.jpg" style="border:0px; vertical-align: top" width="547"/></p><p>Y<sub>1</sub> to Y<sub>4</sub> represent the data inputs while X<sub>1</sub>, X<sub>2</sub> etc. represent the <b>select</b> lines. The bistable (FF) outputs are not shown.</p><p>Selection of an X and Y line allows a logic 1 to be written into an appropriate FF cell.</p><p>This RAM would provide storage for 2 words of 4 bits each and is therefore called a <span class="spCh spChx2018">&#x2018;</span>2 by 4<span class="spCh spChx2019">&#x2019;</span> or 8 bit RAM. In many cases it is desirable to have information permanently stored in a memory. Such a fixed memory is called a Read Only Memory or ROM. ROM<span class="spCh spChx2019">&#x2019;</span>s are used frequently for this purpose. Examples are look-up tables such as trigonometric or logarithmetic tables.</p><p>Another good example is <b>code </b>conversion such as from electric typewriter code to computer ASCII code etc.</p><p>A ROM can be pre-programmed by the manufacturer to suit a customer<span class="spCh spChx2019">&#x2019;</span>s needs. Some ROM<span class="spCh spChx2019">&#x2019;</span>s can be programmed by the customer in the field, only once generally. This type of ROM is usually manufactured containing all logic ones.</p><p>To program this ROM, the customer selects the bit location where he wants a <b>zero</b> and then applies a specified pulse of current. The current flows through a nickel-chromium metallic link which is vapourised by the magnitude of the current. This is similar to <span class="spCh spChx2018">&#x2018;</span>blowing a fuse<span class="spCh spChx2019">&#x2019;</span>. A zero is then permanently stored at this location and it cannot ever be changed. This is called a Programmable Read Only Memory (PROM) and is non-volatile.</p><h2><a id="id11" name="id11"><!--id11--></a>8.1.6 Non flip flop memories</h2><p class="P6">Another type of ROM is available which is both field programmable and field erasable. It can be therefore re-used in a new configuration if desired. It is called an Erasable Programmable Read Only Memory or EPROM.</p><p class="P6">This is a Metal-Oxide-Silicon (MOS) transistor circuit with a floating gate input manufactured as an integrated circuit (IC).</p><p class="P6">To program a logic 1, a voltage is applied to the appropriate gate and a charge is developed on the device. This charge remains when the voltage is removed as there is no discharge path provided.</p><p>The unit can be completely erased of all stored information by exposing it to UV light through a quartz window which is part of the IC case. This removes the charge and the unit can be reprogrammed. This process requires a very intense UV light source for at least 20 minutes to erase the unit. An erased EPROM usually has logic 1<span class="spCh spChx2019">&#x2019;</span>s in all cells.</p><p>A variation to the EPROM is a ROM which can be electronically erased which of course has the advantage of not requiring the UV source. This is called an Electronically Erasable Programmable Read Only Memory or EEPROM or E<sup>2</sup>PROM.</p><h1><a id="id12" name="id12"><!--id12--></a>8.2 Alternative storage systems</h1><p>Semiconductor memories such as those described are normally used by computers to store program instructions and data that the CPU is currently using. Many other programs and files of data in a system may also require storage and alternative storage devices are used for this.</p><p>These devices typically use magnetic storage principles and include: magnetic <b>disks</b> and <b>tapes</b>. However, optical storage device such as CDROMs and DVDs are now more popular for transportable mass storage, while PC cards and USB devices are proving useful for quick data transfer between personal computers.</p><h2><a id="id13" name="id13"><!--id13--></a>8.2.1 Magnetic disks</h2><p>Magnetic disks are used in two forms:</p><ul class="lib"><li><p>flexible diskettes (floppy disks) - rarely used today</p></li><li><p>hard disks (single disks or multiple disk packs).<br/></p></li><li><p><b>Flexible diskettes</b></p></li></ul><p>Flexible diskettes (floppy disks) are no longer used as a principle auxiliary storage medium for personal computers. Although this type of storage was convenient, reliable, and relatively low in cost, it is rarely used today.  However, the principle of operation applies equally to hard drives.</p><p>A floppy disk consists of a circular piece of thin mylar plastic (the actual disk), which is coated with an oxide material similar to that used on magnetic tape. On a 3<span class="spCh spChxbd">&#xBD;</span> inch disk, the circular piece of plastic is enclosed in a rigid plastic cover and a piece of metal called the shutter covers the reading and recording area. When the 3<span class="spCh spChxbd">&#xBD;</span> inch disk is inserted into a disk drive, the drive slides the shutter to the side to expose the disk surface. The term <span class="spCh spChx2018">&#x2018;</span>formatting<span class="spCh spChx2019">&#x2019;</span> is used when preparing a floppy disk for use as a storage medium. Most floppy disks are purchased already formatted. The <b>formatting</b> process includes defining the tracks and sectors on its surface as shown. A <b>track</b> is a narrow recording band forming a full circuit around the disk. Each track on the disk is divided into sectors. A sector is a section of a track. When data is read from a disk a minimum of one full sector is read. When data is stored on a disk, at least one sector is written. The number of tracks and sectors that are placed on a disk when it is formatted varies based on the capacity of the disk. The 3<span class="spCh spChxbd">&#xBD;</span> inch disks are mostly formatted with 80 tracks and 18 sectors on each side. When 80 tracks are recorded on a diskette, the tracks are numbered from 0 to 79.</p><p class="indent"><a name="graphics6"><!-- --></a><img alt="graphics6" class="fr1" height="236" src="module08_files/28c7d7d6_374x236.jpg" style="border:0px; vertical-align: top" width="374"/></p><p class="indent"><b>Floppy disk format</b></p><p>Disks are classified as either <b>hard</b>-sectored or <b>soft</b>-sectored. A hard-sectored disk has a hole in the disk near its centre at the beginning of each sector. These holes provide timing information to the disk drive unit. A soft-sectored disk has a single timing hole only which indicates the start of any track.</p><p class="indent"><a name="graphics7"><!-- --></a><img alt="graphics7" class="fr1" height="126" src="module08_files/509b4c1d_361x126.jpg" style="border:0px; vertical-align: top" width="361"/></p><p>The storage capacity of these disks depends upon the number of sectors, number of tracks and number of sides used. Older disk drives only allow recording on one side of the disk while more recently both sides are used. Typically a high density disk with 80 tracks on each side, eighteen sectors per track can store 512 bytes per sector. This gives a total capacity of (18 <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 512 <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 80 <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 2) = 1 475 560 bytes per disk. The term <span class="spCh spChx2018">&#x2018;</span>cylinder<span class="spCh spChx2019">&#x2019;</span> is often used with double-sided disks meaning all tracks of the same number. For example track 0 on side 1 and track 0 on side 2 of the disk is called cylinder 0. Floppy disks normally rotate at 300 rpm and the read/write head accesses the disk through a slotted hole in the disk<span class="spCh spChx2019">&#x2019;</span>s protective cover. Data is stored using the ASCII code by writing logic ones as magnetic areas on the surface. The read/write head moves laterally across the disk to access the various tracks. The time required to access data is called the access time. It has 4 main components:</p><ul class="lib"><li><p><b>Seek time</b>, the time it takes to position the read/write head over the proper track.</p></li><li><p><b>Latency</b>, the time it takes for the sector containing the data to rotate under the read/write head.</p></li><li><p><b>Settling time</b>, the time required for the read/write head to be placed in contact with the disk.</p></li><li><p><b>Data transfer rate</b>, the time required to transfer the data from the disk to main memory.<br/></p></li></ul><p>The access time for floppy disks is about 150 milliseconds.</p><ul class="lib"><li><p><b>Hard disks</b></p></li></ul><p>Hard disks are constructed of magnetically coated platters permanently mounted-inside the computer in a sealed case and are not accessible like floppy disks. Data is stored in a similar fashion to floppy disks however. The disk unit may have one or more platters attached to a single spindle rotating at high speed, typically 5400 to 7200 rpm. One or more read/write heads floats on a cushion of air just above the disk and do not even touch the disk surface. The storage capacity depends upon the number of platters and is usually in the tens of gigabytes of data. Typical access times are between 5 and 12 msec.</p><h2><a id="id14" name="id14"><!--id14--></a>8.2.2 Magnetic Tapes</h2><p>One of the first storage media used with mainframe computers was tape and it is still used today for mass storage. Magnetic tape consists of a thin band of plastic. The tape is coated on one side with a material that can be magnetised to record the bit patterns that represent data. The most common types of magnetic tape devices are reel-to-reel and cartridge, although reel-to-reel devices have been replaced almost completely by cartridge devices. Reel-to-reel tape is usually <span class="spCh spChxbd">&#xBD;</span> inch wide and cartridge tape is <span class="spCh spChxbc">&#xBC;</span> inch wide.</p><p>Data is recorded on magnetic tape as small magnetised areas similar to our disks. Reel to reel tapes are formatted into a series of horizontal rows called channels. Both EBCDIC and ASCII codes are typically used giving nine channels horizontally along the tape, 7 for the code, 1 for parity and 1 for timing. Tape density is the number of bytes that can be stored per inch of tape. Common densities are 800, 3200, 6250 bytes per inch. Data is stored serially in blocks on a tape with <span class="spCh spChx2018">&#x2018;</span>inter record gaps<span class="spCh spChx2019">&#x2019;</span> between them.</p><p>Typically tapes are 2400 feet long on reels and speeds up to 200 inches per second are used in the transport mechanisms.</p><p>Access time varies depending upon the physical distance to travel from one position to another. Large storage capacities are typical as shown by the following example.</p><p>A magnetic tape with nine tracks of data has a recording density of 200 bits per inch and is 2400 feet long. The tape speed is 75 in/s.</p><ol class="li-lower-alpha" style="list-style: lower-alpha;"><li><p>How much data could be stored on the tape?</p></li><li><p>What is the average access time?</p></li><li><p>What is the maximum access time?</p></li><li><p>What is the data rate in bits per second?<br/></p></li></ol><p><b>Solution</b></p><ol class="li-lower-alpha" style="list-style: lower-alpha;"><li><p>Total length = 2400 <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 12 = 28 800 in. Per track: 200 bits per in. <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 28 800 in. = 5.76&#xA0;<span class="T1"><span class="spCh spChxd7">&#xD7;</span>&#xA0;</span>10<sup>6</sup> bits. The tape can store 5.76 <span class="T1"><span class="spCh spChxd7">&#xD7;</span></span> 10<sup>6</sup> 9-bit words if 100 percent utilisation of the tape is assumed.</p></li><li><p>Average access time is the time to reach half the tape length:</p><p><a name="Object4"><!-- --></a><img alt="Object4" class="fr3" height="39" src="module08_files/77b86c97_179x39bw.png" style="border:0px; vertical-align: top" width="179"/></p></li><li><p>Maximum access time is time to reach the total tape:</p><p><a name="Object7"><!-- --></a><img alt="Object7" class="fr4" height="17" src="module08_files/m53fed308_129x17bw.png" style="border:0px; vertical-align: top" width="129"/></p></li><li><p>&#xA0;</p><p><a name="Object5"><!-- --></a><img alt="Object5" class="fr5" height="65" src="module08_files/581f080f_289x65bw.png" style="border:0px; vertical-align: top" width="289"/></p></li></ol><p>Cartridge tapes are formatted differently. Data is recorded on a single track along the length of the tape. When the end is reached, the tape reverses direction and data is recorded in another track in the opposite direction. Up to seven tracks may be formatted on to a <span class="spCh spChxbc">&#xBC;</span> inch wide tape. Tape densities range from 6 000bpi to more than 60 000bpi</p><h2><a id="id15" name="id15"><!--id15--></a>8.2.3 Optical storage</h2><p>To store large amounts of data an optical disk system can be used. A laser is used to burn microscopic holes into the surface of a plastic disk. A lower power laser can then be used to detect the presence or absence of these holes by reflection from the surface. The presence or absence of holes represents logic 1 or 0 respectively.</p><p>A full-size 12 inch optical disk can store several billion characters of information. Smaller disks, about five inches in diameter, can store over 800 million characters or approximately 600 times the data that can be stored on a 3<span class="spCh spChxbd">&#xBD;</span> inch floppy disk. The smaller optical disks are called <b>CDROM</b>, for compact disk read-only memory. They use the same laser technology that is used for the CDs disks that have become popular for recorded music.</p><h1><a id="id16" name="id16"><!--id16--></a>8.3 The Central Processing Unit (CPU)</h1><h2><a id="id17" name="id17"><!--id17--></a>8.3.1 Introduction</h2><p class="P6">The simplified central processing unit (CPU) contains the control unit and the arithmetic/logic unit. These two components combine using the program and data stored in memory to perform the processing operations.</p><p class="P6">The <b>control unit</b> operates by using the following four operations: fetching, decoding, executing, and storing. <b>Fetching</b> means obtaining the next program instruction from memory. <b>Decoding</b> is translating the program instruction into the commands that the computer can process. <b>Executing</b> refers to the actual processing of the computer commands, and <b>storing</b> takes place when the result of the instruction is written to memory.</p><p>The central processing unit (CPU) performs and controls all the operations. It also contains the Arithmetic Logic Unit (ALU) which can ADD, SUBTRACT, AND, OR and EXOR. The CPU has a number of temporary storage areas known as <b>registers</b>. Registers are used to supply memory addresses, receive data and store data for intermediate operations. One register in the system is the most important and is used for all operations. It is usually known as the <b>accumulator</b> (ACC).</p><p>The CPU handles binary information of a specific number of bits. 8, 16, 32 and 64 are common and the number of bits is called the <b>word size</b>. Generally the larger the word size the more complex, accurate and costly is the computer. When a CPU is constructed, it has designed into it the capacity to perform a fixed set of operations. These operations are activated by a set of instructions provided by the manufacturer.</p><p>Typical instructions are: <b>add</b>, <b>subtract</b>, <b>load</b>, <b>store</b> and <b>branch</b>. These are usually abbreviated to three letter representations called <b>mnemonics</b>. For the above instructions, the mnemonics are ADD, SUB, LDA, STA and BRA.</p><h2><a id="id18" name="id18"><!--id18--></a>8.3.2 The instruction set</h2><p>To solve a problem a technique is usually decided upon by the programmer and he defines it by means of a <b>flowchart</b>. Each step in the flowchart can be executed by means of an instruction obtained from the total list of instructions provided by the manufacturer. This list is known as an <b>instruction</b> <b>set</b>. The completed program is stored in the memory and when started, instructions are fetched in sequence, decoded and executed automatically. This type of operation is known as the <b>stored</b> <b>program</b> <b>concept</b>.</p><p>Each instruction in the set has a unique binary code describing it. This is known as its <b>machine</b> <b>code</b>, <b>source</b> <b>code</b> or <b>operation</b> <b>code</b> (OPCODE).</p><p>A set of codes to perform a set task is known as a <b>machine language program</b>.</p><p>An example of some typical instructions in a set is now shown. Consider the first name in the instruction set. The operation required by the programmer is ADD, the mnemonic is ADD, the code is 9B hexadecimal and the description for the action is shown in the last column.</p><p class="table-caption-above"><b>Table </b><b>8</b><b>.</b><b>1</b><b>:</b> Instruction set</p><div class="Table6" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table6" style="border-spacing: 0;empty-cells: show; keep-with-next:always; width:14.601cm; border-collapse: collapse; border: 1.0px solid #000000"><colgroup><col style="width:2.514cm;"/><col style="width:2.955cm;"/><col style="width:2.272cm;"/><col style="width:6.862cm;"/></colgroup><tbody><tr><td class="Table6_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>Name</b></p></td><td class="Table6_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>Mnemonic</b></p></td><td class="Table6_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>OPCODE</b></p></td><td class="Table6_D1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>Description</b></p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">ADD</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">ADD</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">10011011 or 9B<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Add the contents of the location whose address is given in the <span class="spCh spChx2018">&#x2018;</span>operand address field<span class="spCh spChx2019">&#x2019;</span> to the accumulator. The result remaining in the accumulator.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">SUBTRACT</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">SUB</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">10010000 or 90<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Subtract the contents of the location whose address is given in the <span class="spCh spChx2018">&#x2018;</span>operand address field<span class="spCh spChx2019">&#x2019;</span> from the accumulator. The result remaining in the accumulator.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">Load the accumulator</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">LDA</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">10010110 or 96<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Load the contents of the location whose address is given in the operand address field into the accumulator.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">Store the accumulator</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">STA</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">10010111 or 97<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Store the contents of the accumulator into the address given in the <span class="spCh spChx2018">&#x2018;</span>operand address field<span class="spCh spChx2019">&#x2019;</span>.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">Branch</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">BRA</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">00110000 or 30<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Branch to the address given in the operand address field.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">Branch if minus</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">BMI</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">00110001 or 31<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Branch to the address given in the operand address field <b>if</b> the status of the previous result was negative. If <b>not</b> negative <b>do not</b> Branch.</p></td></tr><tr><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">HALT</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">HLT</p></td><td class="Table6_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">00111111 or 3F<sub>16</sub></p></td><td class="Table6_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Stop all operations.</p></td></tr></tbody></table></div><p/><div class="Table8" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table8" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:1.61cm;"/><col style="width:12.991cm;"/></colgroup><tbody><tr><td class="Table8_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><b>N.B.</b></p></td><td class="Table8_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>The <b>mnemonic </b>is the accepted abbreviation representing the instruction.</p></td></tr></tbody></table></div><p/><p>For example, when the computer received the hexadecimal number 9B, it knows that means ADD two numbers together and put the result in the accumulator register. The use of these instructions in a program will be shown later in the module.</p><h2><a id="id19" name="id19"><!--id19--></a>8.3.3 Instruction content</h2><p class="P6">To help introduce the architecture of a CPU a simplified conceptual development of the instruction content will be considered. This is based on what information is required in an instruction to allow the CPU to perform the desired operation.</p><p class="P6">Consider the basic computer operation <span class="spCh spChx2018">&#x2018;</span>ADD<span class="spCh spChx2019">&#x2019;</span>.</p><div class="Table9" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table9" style="border-spacing: 0;empty-cells: show; keep-with-next:always; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:0.926cm;"/><col style="width:2.161cm;"/><col style="width:11.515cm;"/></colgroup><tbody><tr><td class="Table9_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p class="P6">i.e.<br/>&#xA0;</p></td><td class="Table9_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p class="P6">A + B = C<br/>&#xA0;</p></td><td class="Table9_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p class="P6">where A, B and C are the address of the memory locations, the contents of which are to be used in the addition operation.</p></td></tr></tbody></table></div><p class="P6"/><p class="P6">Based on the understanding that the computer must be told <b><span class="spCh spChx2018">&#x2018;</span>Exactly what to do<span class="spCh spChx2019">&#x2019;</span></b>, the following can be deduced:</p><ul class="lib"><li><p>The computer must be told to ADD.</p></li><li><p>The addition must be performed on two numbers (operands) and the address of each must be specified.</p></li><li><p>The address of the result must be included.<br/></p></li></ul><p>and</p><ul class="lib"><li><p>Having completed this instruction, the CPU must be told <b><span class="spCh spChx2018">&#x2018;</span>What to do next<span class="spCh spChx2019">&#x2019;</span></b>, i.e., the address of the next instruction.<br/></p></li></ul><p>This can be summarised in an instruction form as</p><div class="Table10" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table10" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:1.499cm; width:12.502cm; border-collapse: collapse; "><colgroup><col style="width:2.514cm;"/><col style="width:2.492cm;"/><col style="width:2.491cm;"/><col style="width:2.514cm;"/><col style="width:2.492cm;"/></colgroup><tbody><tr><td class="Table10_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">OPCODE<br/>FIELD<br/>(i.e. <span class="spCh spChx2018">&#x2018;</span>ADD<span class="spCh spChx2019">&#x2019;</span>)</p></td><td class="Table10_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Address of 1st operand<br/>(i.e. A)</p></td><td class="Table10_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Address of 2nd operand<br/>(i.e. B)</p></td><td class="Table10_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Address of the result<br/>(i.e. C)</p></td><td class="Table10_E1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center">Address<br/>of next instruction</p></td></tr></tbody></table></div><p/><p>Given that this instruction must be a coded binary number, i.e., in machine code, the impractical nature of this instruction can be highlighted as follows:</p><p class="indent">For a very simple computer with only 8 instructions and a memory of only 32 locations the length of each instruction becomes:</p><ul class="lib"><li><p>OPCODE requires <span class="spCh spChx2018">&#x2018;</span>3 bits<span class="spCh spChx2019">&#x2019;</span>. (8 instructions, one of which is ADD).</p></li><li><p>each address must be 5 bits since the memory size is 32 locations.<br/></p><div class="Table11" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table11" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:4.013cm; width:9.989cm; border-collapse: collapse; "><colgroup><col style="width:1.984cm;"/><col style="width:2.007cm;"/><col style="width:2.006cm;"/><col style="width:2.007cm;"/></colgroup><tbody><tr><td class="Table11_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">&#xA0;&#xA0;3&#xA0;bits&#xA0;&#xA0;</p></td><td class="Table11_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">&#xA0;&#xA0;5&#xA0;bits&#xA0;&#xA0;</p></td><td class="Table11_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">&#xA0;&#xA0;5&#xA0;bits&#xA0;&#xA0;</p></td><td class="Table11_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">&#xA0;&#xA0;5&#xA0;bits&#xA0;&#xA0;</p></td><td class="Table11_E1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center">&#xA0;&#xA0;5&#xA0;bits&#xA0;&#xA0;</p></td></tr></tbody></table></div></li></ul><p/><p class="indent" style="keep-with-next:always; ">This instruction will therefore be 23 bits long. For a memory of realistic size, i.e., 4K, each address would be 12 bits giving an unworkable instruction length of 51 bits.</p><div class="Table12" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table12" style="border-spacing: 0;empty-cells: show; keep-with-next:always; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:1.279cm;"/><col style="width:13.323cm;"/></colgroup><tbody><tr><td style="vertical-align: top; "><p><b>N.B.<br/>&#xA0;<br/>&#xA0;&#xA0;</b></p></td><td style="vertical-align: top; "><p class="P5">1K refers to 1000 memory locations. In fact, 1K of memory requires a 10 bit address and the actual number of locations is 1024, i.e. 2<sup>10</sup> = 1024. For a 12 bit address the number of locations which can be addressed is 2<sup>12</sup> or 4096. (i.e. 4K; locations 0 to 4095)</p></td></tr></tbody></table></div><p/><h2><a id="id20" name="id20"><!--id20--></a>8.3.4 Reduction of instruction word length</h2><p class="P6">The information provided in the above instruction is essential and no matter what modifications are made, the same information must be somehow imparted to the CPU. However, it is <b>too lengthy</b>. A reduction in the instruction length is accomplished by a compromise between</p><div class="Table13" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table13" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; "><colgroup><col style="width:0.905cm;"/><col style="width:13.697cm;"/></colgroup><tbody><tr><td style="vertical-align: top; "><p/></td><td style="vertical-align: top; "><ul class="lib"><li><p>introducing extra hardware in the CPU. This reduces flexibility and limits the operation of each instruction.</p></li></ul></td></tr><tr><td style="vertical-align: top; "><p>and</p></td><td style="vertical-align: top; "><p/></td></tr><tr><td style="vertical-align: top; "><p/></td><td style="vertical-align: top; "><ul class="lib"><li><p>adding further instructions to compensate. This increases the program length.</p></li></ul></td></tr></tbody></table></div><p/><p>The reduction is accomplished as follows:</p><ul class="lib"><li><p>Most programs are largely sequential in nature causing instructions to be fetched in sequence from sequential locations in memory. Only occasionally will a BRANCH or JUMP to a different section of program be required, e.g. in a program loop.</p><p>The conclusion is to remove the need for the <span class="spCh spChx2018">&#x2018;</span>Next Instruction Address<span class="spCh spChx2019">&#x2019;</span> and in its place, put as part of the CPU a hardware binary counter. This counter can be incremented during the execution of each instruction in readiness to provide the next instruction address in sequence.</p><p>This counter is called the <b><span class="spCh spChx2018">&#x2018;</span>Program Counter<span class="spCh spChx2019">&#x2019;</span></b> or PC. In all digital computers:</p><div class="Table21" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table21" style="border-spacing: 0;empty-cells: show; margin-left:1.057cm; margin-right:0.072cm; width:13.473cm; border-collapse: collapse; "><colgroup><col style="width:13.473cm;"/></colgroup><tbody><tr><td style="vertical-align: top; "><p><i>The&#xA0;address&#xA0;of&#xA0;the&#xA0;instruction&#xA0;to&#xA0;be&#xA0;fetched&#xA0;is&#xA0;provided&#xA0;by&#xA0;the&#xA0;<span class="spCh spChx2018">&#x2018;</span>program&#xA0;counter<span class="spCh spChx2019">&#x2019;</span></i></p></td></tr></tbody></table></div><p/><p>e.g., To start a program (fetch the first instruction), the address of the memory location, containing the first instruction, must be placed in the PC.</p><p>To alter the sequence of a program, i.e. as in a loop, special instructions must be added to load the PC with a new instruction address.</p><p>Such instructions are:</p><p><a name="Object6"><!-- --></a><img alt="Object6" class="fr6" height="68" src="module08_files/md3ba61d_168x68bw.png" style="border:0px; vertical-align: top" width="168"/></p></li><li><p>The instruction length can be further reduced by making the address of one of the OPERANDS also the address of the result.</p><p>i.e., this is equivalent to the statement</p><div class="Table22" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table22" style="border-spacing: 0;empty-cells: show; margin-left:1.122cm; margin-right:10.634cm; width:2.845cm; border-collapse: collapse; "><colgroup><col style="width:2.845cm;"/></colgroup><tbody><tr><td style="vertical-align: top; "><p>A&#xA0;&#xA0;=&#xA0;&#xA0;A&#xA0;&#xA0;+&#xA0;&#xA0;B</p></td></tr></tbody></table></div><p/><p>This removes the need for the <span class="spCh spChx2018">&#x2018;</span>Result address<span class="spCh spChx2019">&#x2019;</span>.</p><p>This can be taken further by allocating a small section of memory (e.g. locations 0, 1, 2 and 3) to be reserved as <b>working registers</b>. All operations must then be performed between one of these <span class="spCh spChx2018">&#x2018;</span>working registers<span class="spCh spChx2019">&#x2019;</span> and an OPERAND from memory.</p><p>i.e., <span class="spCh spChx2018">&#x2018;</span>Reg 0<span class="spCh spChx2019">&#x2019;</span> + A and put result in <span class="spCh spChx2018">&#x2018;</span>Reg 0<span class="spCh spChx2019">&#x2019;</span>.</p><p>This further saves on instruction length since in place of the <span class="spCh spChx2018">&#x2018;</span>Address of the second OPERAND<span class="spCh spChx2019">&#x2019;</span> there now only needs to be <span class="spCh spChx2018">&#x2018;</span>2 bits<span class="spCh spChx2019">&#x2019;</span> to specify one of 4 working registers.</p><p>The instruction becomes:</p><div class="Table14" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table14" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:4.674cm; width:9.327cm; border-collapse: collapse; "><colgroup><col style="width:2.977cm;"/><col style="width:2.999cm;"/><col style="width:3.351cm;"/></colgroup><tbody><tr><td class="Table14_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">OPCODE<br/>Field</p></td><td class="Table14_A1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Register <br/>Field</p></td><td class="Table14_C1" style="vertical-align: top;  border:1.0px solid #000000;  padding:0.097cm; "><p class="center">Operand Address Field</p></td></tr></tbody></table></div><p/><p>In general, however, the <span class="spCh spChx2018">&#x2018;</span>working registers<span class="spCh spChx2019">&#x2019;</span> are separated away from the memory and become part of the CPU. This makes it easier and quicker for the CPU since it does not have to continually supply an address in memory for registers 0 to 3. The number of <span class="spCh spChx2018">&#x2018;</span>working registers<span class="spCh spChx2019">&#x2019;</span> in a CPU will vary from one make of CPU to another.</p><p>In cases where the number of <span class="spCh spChx2018">&#x2018;</span>working registers<span class="spCh spChx2019">&#x2019;</span> is limited to <b>one</b> or <b>two</b>, they are commonly referred to as <span class="spCh spChx2018">&#x2018;</span>Accumulator<span class="spCh spChx2019">&#x2019;</span> ALU operations such as ADD, SUB, AND, OR etc., are always performed with one operand as the <span class="spCh spChx2018">&#x2018;</span>accumulator<span class="spCh spChx2019">&#x2019;</span> and the result being left in the accumulator.</p><p>i.e., (accumulator) + operand <span class="T2"><span class="spCh spChx2192">&#x2192;</span></span> result in (accumulator).</p><p>This has limited the original concept of <span class="spCh spChx2018">&#x2018;</span>ADD<span class="spCh spChx2019">&#x2019;</span> as illustrated in the beginning of this section, however, extra instructions are available to offset this limitation.</p><div class="Table15" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table15" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; width:13.91cm; border-collapse: collapse; "><colgroup><col style="width:1.72cm;"/><col style="width:1.191cm;"/><col style="width:1.346cm;"/><col style="width:9.654cm;"/></colgroup><tbody><tr><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>LDA</p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>C</p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>load the contents of <span class="spCh spChx2018">&#x2018;</span>C<span class="spCh spChx2019">&#x2019;</span> into the accumulator.</p></td></tr><tr><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>STA</p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>D</p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td class="Table15_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>store the accumulator contents into address D.</p></td></tr></tbody></table></div><p/><p>The operation A + B = C now becomes:</p><div class="Table16" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table16" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; width:12.959cm; border-collapse: collapse; "><colgroup><col style="width:1.72cm;"/><col style="width:1.191cm;"/><col style="width:1.367cm;"/><col style="width:8.682cm;"/></colgroup><tbody><tr><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>LDA</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>B</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>put B in the accumulator.</p></td></tr><tr><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>ADD</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>A</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>(accumulator + A) <span class="T2"><span class="spCh spChx2192">&#x2192;</span></span> accumulator.</p></td></tr><tr><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>STA</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>C</p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td class="Table16_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>store accumulator into C.</p></td></tr></tbody></table></div><p/><p>The accumulator becomes an extremely important register which is the central element in a large number of operations. The major uses of the accumulator are:</p><ul class="lib"><li><p>All ALU functions are performed with the accumulator initially providing one of the operands and later storing the result of the operation.</p></li><li><p>It is the register which is used to transfer data between the CPU and I/O devices, and into and out of memory.</p><p>(<b>N.B.</b> I/O is the abbreviation for <b>input/output</b>.)</p></li></ul><p>Some CPU architectures will have:</p><ul class="lib"><li><p>one accumulator only</p></li></ul><p>or</p><ul class="lib"><li><p>several working registers all of which can be used as accumulators as outlined above</p></li></ul><p>or</p><ul class="lib"><li><p>several working registers but only selected ones can act as accumulators. The remainder being used for temporary storage only and not for operations involving the ALU.</p></li></ul><p>The final result of all these actions is that the instruction will have an added component called the <span class="spCh spChx2018">&#x2018;</span>Address Mode Field<span class="spCh spChx2019">&#x2019;</span> which we will consider later. For a memory size of 64K (16 address lines) the instruction length is still considerable.</p><p>The trend is to still limit the size of a memory word, e.g. to 8 bits, and to store the instruction over more than 1 location in memory.</p><p>e.g.</p><div class="Table17" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table17" style="border-spacing: 0;empty-cells: show; margin-left:1.189cm; margin-right:0.072cm; width:13.34cm; border-collapse: collapse; "><colgroup><col style="width:2.425cm;"/><col style="width:2.228cm;"/><col style="width:2.91cm;"/><col style="width:2.932cm;"/><col style="width:2.845cm;"/></colgroup><tbody><tr><td class="Table17_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="center">8 BITS</p></td><td class="Table17_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">OPCODE<br/>Field</p></td><td class="Table17_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Register<br/>Field</p></td><td class="Table17_B1" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center">Address Mode Field</p></td><td class="Table17_E1" style="vertical-align: top;  border-bottom:none;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">ADD</p></td></tr><tr><td class="Table17_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="center"/></td><td class="Table17_B2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:none;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center"/></td><td class="Table17_B2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:none;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center"/></td><td class="Table17_B2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:none;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center"/></td><td class="Table17_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="center"/></td></tr><tr><td class="Table17_A1" style="vertical-align: top;  border:none;  padding:0.097cm; "><p class="center">8 BITS</p></td><td class="Table17_B3" colspan="3" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">Operand Address Field</p></td><td class="Table17_E1" style="vertical-align: top;  border-bottom:none;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center"/></td></tr></tbody></table></div></li></ul><p/><h2><a id="id21" name="id21"><!--id21--></a>8.3.5 Structure of an elementary CPU</h2><p><b>Refer to figure 8.1</b></p><p>The function of some of the elements of Figure 8.1 have already been considered. Studying the function of each block in turn, consider:</p><ul class="lib"><li><p><b>The program counter</b> <span class="spCh spChx2013">&#x2013;</span> always supplies the address of the next instruction.</p></li><li><p><b>The status register</b> <span class="spCh spChx2013">&#x2013;</span> holds the status bits set at the end of execution of the previous instruction.</p><div class="Table18" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table18" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; width:12.13cm; border-collapse: collapse; "><colgroup><col style="width:1.102cm;"/><col style="width:11.028cm;"/></colgroup><tbody><tr><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>i.e.</p></td><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>C if a carry was generated.</p></td></tr><tr><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p/></td><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>V if a 2<span class="spCh spChx2019">&#x2019;</span>s complement overflow occurred.</p></td></tr><tr><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p/></td><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>Z if the result was zero.</p></td></tr><tr><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p/></td><td class="Table18_A1" style="vertical-align: top;  border:none;  padding-bottom:0.101cm;  padding-left:1.0px;  padding-right:1.0px;  padding-top:0.101cm; "><p>N if the result was negative.</p></td></tr></tbody></table></div><p>(This will be explained in a later module.)</p></li><li><p><b>The Arithmetic Logic Unit</b> (ALU) <span class="spCh spChx2013">&#x2013;</span> is that circuitry in the CPU which performs the arithmetic and logic functions. These commonly are ADD, ADD with carry, SUB, SUB with BORROW, AND, OR, EXCLUSIVE-OR, INVERT (OR COMPLEMENT).</p><p>The ALU has two data inputs, one from the accumulator, the other is the operand from memory which is taken from the data bus via the data register. The output of the ALU is stored back into the accumulator.</p><p>Which particular ALU function is performed is determined by control lines (not shown on figure 8.1) from the <b>controller/sequencer</b>.</p></li><li><p><b>The accumulator</b> <span class="spCh spChx2013">&#x2013;</span> This is a general purpose working register whose primary function is for use in conjunction with the ALU.</p><p><i>it holds one of the operands in an ALU operation and it holds the result following the ALU operation</i>.</p><p>In general no matter what a program endeavours to do with data, it must first be put into the accumulator.</p><p><b>Note</b> <span class="spCh spChx2013">&#x2013;</span> It is possible to <span class="spCh spChx2018">&#x2018;</span>Read<span class="spCh spChx2019">&#x2019;</span> the operand from the <span class="spCh spChx2018">&#x2018;</span>accumulator<span class="spCh spChx2019">&#x2019;</span> and <span class="spCh spChx2018">&#x2018;</span>write<span class="spCh spChx2019">&#x2019;</span> the result back into the <span class="spCh spChx2018">&#x2018;</span>accumulator<span class="spCh spChx2019">&#x2019;</span> in one operation. This is possible because of the special features of the master-slave flip/flop.<br/></p></li></ul><p class="figure-caption-above"><b>Figure </b><b>8</b><b>.</b><b>1</b><b>:</b> </p><p class="indent"><a name="graphics8"><!-- --></a><img alt="graphics8" class="fr1" height="522" src="module08_files/5025b621_422x522.jpg" style="border:0px; vertical-align: top" width="422"/></p><ul class="lib"><li><p><b>Data register</b> <span class="spCh spChx2013">&#x2013;</span> This is a temporary storage register whose function is to act as a buffer between the Data Bus and the CPU. The name given to the Data Register varies depending on the text, e.g. <b>data buffer</b> or <b>data buffer register</b>. In some texts it isn<span class="spCh spChx2019">&#x2019;</span>t included at all.</p></li><li><p><b>Address register</b> <span class="spCh spChx2013">&#x2013;</span> A temporary storage register which holds the address of the memory location, or I/O device, being used in the present operation. Its purpose is to act as a buffer and to latch (hold the value) the address supplied by the CPU. This is often referred to as the <span class="spCh spChx2018">&#x2018;</span>Memory Address Register<span class="spCh spChx2019">&#x2019;</span>.</p></li><li><p><b>Instruction decoder/controller sequencer</b> <span class="spCh spChx2013">&#x2013;</span> Often referred to as the <span class="spCh spChx2018">&#x2018;</span>Control Unit<span class="spCh spChx2019">&#x2019;</span> which decodes the instruction, decides what operation is to be performed and supplies all gating and control signals to execute the instruction. Since each instruction is different, a separate control sequence is initiated by each instruction. It is the function of the control unit to <span class="spCh spChx2018">&#x2018;</span>gate<span class="spCh spChx2019">&#x2019;</span> the contents of the <span class="spCh spChx2018">&#x2018;</span>PC<span class="spCh spChx2019">&#x2019;</span> into the Address Register, to send out <span class="spCh spChx2018">&#x2018;</span><b>Memory</b> Read<span class="spCh spChx2019">&#x2019;</span> etc., to execute the instruction.<br/></p></li></ul><p class="P9">The word size and the address range (i.e. number of address lines) will vary depending on the CPU, e.g. minicomputer or microprocessor. In the following sections it will be assumed that the word size is 8 bits, the address bus is 8 bits, i.e. it can address memory from 0 <span class="spCh spChx2013">&#x2013;</span> 255<sub>10</sub>, and each memory location is also 8 bits.</p><p>We will now consider an example of using the processor to solve a simple problem. This example is designed to illustrate the <span class="spCh spChx2018">&#x2018;</span>concepts<span class="spCh spChx2019">&#x2019;</span> of machine code programming only. In module 11 we will write a program for this problem in the international format used by all programmers.</p><h1><a id="id22" name="id22"><!--id22--></a>8.4 Program example</h1><p>Write a program using the stored program concept to execute the following numerical example:</p><div class="Table19" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table19" style="border-spacing: 0;empty-cells: show; margin-left:0.6cm; margin-right:10.253cm; width:3.748cm; border-collapse: collapse; "><colgroup><col style="width:0.75cm;"/><col style="width:0.773cm;"/><col style="width:0.706cm;"/><col style="width:0.771cm;"/></colgroup><tbody><tr><td class="Table19_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p>9</p></td><td class="Table19_A1" style="vertical-align: top;  border:none;  padding:1.0px; "><p><span class="spCh spChx2013">&#x2013;</span></p></td><td style="vertical-align: top; "><p>5</p></td><td style="vertical-align: top; "><p>+</p></td><td style="vertical-align: top; "><p>2</p></td></tr></tbody></table></div><p/><p>It is normal programming practice to draw a flowchart indication the technique used to solve the problem. We also know that all operations are performed in the accumulator register.</p><p><b>NOTE</b>: This example is <b>not</b> designed to run on the 68HC11 microcontroller.</p><h2><a id="id23" name="id23"><!--id23--></a>8.4.1 Flowcharts</h2><p class="indent"><a name="graphics9"><!-- --></a><img alt="graphics9" class="fr1" height="347" src="module08_files/m9b1e2b_146x347.jpg" style="border:0px; vertical-align: top" width="146"/></p><p>We will also suppose the memory starts at location zero. i.e. 00 Hexadecimal and goes to location FF. Using the table 8.1 instruction set we set out a program in the following columns known as <span class="spCh spChx2018">&#x2018;</span>fields<span class="spCh spChx2019">&#x2019;</span>.</p><h2><a id="id24" name="id24"><!--id24--></a>8.4.2 Program development</h2><div class="Table20" style="width: 100%; margin: 0px; padding: 0px; text-align:left;"><table class="Table20" style="border-spacing: 0;empty-cells: show; width:14.601cm; border-collapse: collapse; border: 1.0px solid #000000"><colgroup><col style="width:2.505cm;"/><col style="width:7.087cm;"/></colgroup><tbody><tr><td class="Table20_A1" style="vertical-align: top;  border-bottom:1.0px double #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>&#xA0;&#xA0;Location&#xA0;&#xA0;</b></p></td><td class="Table20_A1" style="vertical-align: top;  border-bottom:1.0px double #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>&#xA0;&#xA0;Contents&#xA0;&#xA0;</b></p></td><td class="Table20_A1" style="vertical-align: top;  border-bottom:1.0px double #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>&#xA0;&#xA0;Mnemonic&#xA0;&#xA0;</b></p></td><td class="Table20_D1" style="vertical-align: top;  border-bottom:1.0px double #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:1.0px solid #000000;  padding:0.097cm; "><p class="center"><b>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Comments&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</b></p></td></tr><tr><td class="Table20_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">00<br/>01<br/>02<br/>03<br/>04<br/>05<br/><br/>06<br/>07<br/><br/>08<br/>09</p></td><td class="Table20_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center">09<br/>05<br/>02<br/>96<br/>00<br/>90<br/><br/>01<br/>9B<br/><br/>02<br/>3F</p></td><td class="Table20_A2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:none;  border-top:none;  padding:0.097cm; "><p class="center"><span class="spCh spChx2013">&#x2013;</span><br/><span class="spCh spChx2013">&#x2013;</span><br/><span class="spCh spChx2013">&#x2013;</span><br/>LDA<br/><br/>SUB<br/><br/><br/>ADD<br/><br/><br/>HLT</p></td><td class="Table20_D2" style="vertical-align: top;  border-bottom:1.0px solid #000000;  border-left:1.0px solid #000000;  border-right:1.0px solid #000000;  border-top:none;  padding:0.097cm; "><p>Number 9 stored in location 00.<br/>Number 5 stored in location 01.<br/>Number 2 stored in location 02.<br/>Load accumulator from location 00.<br/><br/>Subtract the contents of location 01 <br/>from the accumulator.<br/><br/>Add the contents of location 02 to the<br/>accumulator.<br/><br/>Stop all operations.</p></td></tr></tbody></table></div><p/><p>To run the program, the hexadecimal contents column would be typed into the computer and the program would be started at location 03. The computer would halt at location 09 and the result or answer to this problem would rest in the accumulator.</p><p/></div>